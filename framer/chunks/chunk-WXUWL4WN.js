// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 1763929c89cf4969 "Patrick McKowen", do not edit manually */
import {
  __export,
  __reExport
} from "./chunk-IRNZKG45.js";

// /:https://framerusercontent.com/modules/OyQTynK6SZJkLA6wYpTv/XdGxLGHd8DKcr2HGyULS/ShaderGradient.js
import { jsx as _jsx } from "react/jsx-runtime";

// /:https://esm-shadergradient.onrender.com/without-store.mjs
var without_store_exports = {};
__export(without_store_exports, {
  Placeholder: () => ki,
  ShaderGradient: () => gg,
  ShaderGradientCanvas: () => gf
});
__reExport(without_store_exports, fiber_star);
import { Canvas as na } from "@react-three/fiber";
import { useState as oa } from "react";
import { jsx as Vi } from "react/jsx-runtime";
import { Fragment as sa, jsx as Cr } from "react/jsx-runtime";
import { useEffect as Ra, useMemo as wa } from "react";
import { BufferGeometry as da, Clock as ma, Float32BufferAttribute as Xi, LinearFilter as qi, Mesh as zf, OrthographicCamera as ha, RGBAFormat as pa, Vector2 as ji, WebGLRenderTarget as ga } from "three";
import { BufferGeometry as aa, Float32BufferAttribute as Gi, OrthographicCamera as ca, Mesh as la } from "three";
import { ShaderMaterial as Yi, UniformsUtils as ua } from "three";
import { Color as va } from "three";
import { ShaderMaterial as Pa, UniformsUtils as Ca } from "three";
import { EventDispatcher as _a, Uniform as ya } from "three";
import { BufferGeometry as Ea, Float32BufferAttribute as ho, OrthographicCamera as ba, Mesh as Sa } from "three";
import { useThree as za, useFrame as Aa } from "@react-three/fiber";
import * as Y from "react";
import { createPortal as Va, useFrame as ka, useThree as ke } from "@react-three/fiber";
import { Matrix4 as Ga, Object3D as Ya, Quaternion as bo, Scene as qa, Vector3 as Ht } from "three";
import * as ve from "react";
import { useThree as Lr, useFrame as Fa } from "@react-three/fiber";
import * as Ve from "react";
import * as Le from "three";
import { useThree as Oa } from "@react-three/fiber";
import { Fragment as Ia, jsx as _o, jsxs as Ma } from "react/jsx-runtime";
import * as xo from "react";
import { Raycaster as Na, Camera as Ua } from "three";
import { useThree as Ha, applyProps as Ba } from "@react-three/fiber";
import { jsx as Ro, jsxs as Za } from "react/jsx-runtime";
import * as Vt from "react";
import { useThree as Qa } from "@react-three/fiber";
import { CanvasTexture as Ka } from "three";
import { Fragment as Lo, jsx as Q, jsxs as Bt } from "react/jsx-runtime";
import { Fragment as $a, jsx as Dr } from "react/jsx-runtime";
import * as ic from "three";
import { useEffect as Zo, useRef as tc } from "react";
import { useFrame as rc } from "@react-three/fiber";
import { extend as oc, useThree as Ko } from "@react-three/fiber";
import { jsx as nc } from "react/jsx-runtime";
import cc from "react";
import { EquirectangularReflectionMapping as lc } from "three";
import { useThree as fc } from "@react-three/fiber";
import { DataTextureLoader as sc, HalfFloatType as Xt, FloatType as jr, DataUtils as Zt, LinearFilter as Wo } from "three";
import { useLoader as ac } from "@react-three/fiber";
import { Suspense as hc, useEffect as pc } from "react";
import { useState as mc } from "react";
import { DefaultLoadingManager as en } from "three";
import { Fragment as vc, jsx as mt, jsxs as _c } from "react/jsx-runtime";
import { applyProps as Ul, addEffect as Hl } from "@react-three/fiber";
import { useRef as Tm } from "react";
import { useState as jc } from "react";
import { useRef as Xc } from "react";
import { useEffect as Zc, useLayoutEffect as Qc } from "react";
import { useEffect as $c, useRef as Wc, useState as Jc } from "react";
import { useEffect as tl } from "react";
import { useEffect as il, useRef as ol } from "react";
import { useState as Om } from "react";
import { useContext as xl, useMemo as fr, useRef as Nn } from "react";
import * as In from "react";
import { forwardRef as al, useRef as zn, useCallback as cl, useEffect as ll } from "react";
import * as dr from "react";
import { useContext as Ol } from "react";
import { useState as xh } from "react";
import * as as from "react";
import { useContext as Th, useRef as Ph, useMemo as Ch } from "react";
import { useRef as Lh, useState as Oh } from "react";
import * as Bl from "three";
import "@react-three/fiber";
import { extend as Ss } from "@react-three/fiber";
import { useState as Gl, useEffect as Yl } from "react";
import * as hr from "three";
import * as rt from "three";
import { useFrame as ql } from "@react-three/fiber";
import { useRef as Ps } from "react";
import * as Rs from "three";
import { jsx as Ee, jsxs as Ai } from "react/jsx-runtime";
import { Fragment as of, jsx as Sr, jsxs as nf } from "react/jsx-runtime";
import * as fiber_star from "@react-three/fiber";
var __unframerWindow = typeof window !== "undefined" ? window : void 0;
var __unframerNavigator = typeof __unframerWindow !== "undefined" ? navigator : void 0;
var Ks = Object.create;
var Lt = Object.defineProperty;
var $s = Object.defineProperties;
var Ws = Object.getOwnPropertyDescriptor;
var Js = Object.getOwnPropertyDescriptors;
var ea = Object.getOwnPropertyNames;
var At = Object.getOwnPropertySymbols;
var ta = Object.getPrototypeOf;
var Tr = Object.prototype.hasOwnProperty;
var Ui = Object.prototype.propertyIsEnumerable;
var Ni = (e, t, r) => t in e ? Lt(e, t, { enumerable: true, configurable: true, writable: true, value: r }) : e[t] = r;
var M = (e, t) => {
  for (var r in t ||= {}) Tr.call(t, r) && Ni(e, r, t[r]);
  if (At) for (var r of At(t)) Ui.call(t, r) && Ni(e, r, t[r]);
  return e;
};
var W = (e, t) => $s(e, Js(t));
var J = (e, t) => {
  var r = {};
  for (var i in e) Tr.call(e, i) && t.indexOf(i) < 0 && (r[i] = e[i]);
  if (e != null && At) for (var i of At(e)) t.indexOf(i) < 0 && Ui.call(e, i) && (r[i] = e[i]);
  return r;
};
var ot = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var pe = (e, t) => {
  for (var r in t) Lt(e, r, { get: t[r], enumerable: true });
};
var ra = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function") for (let o of ea(t)) !Tr.call(e, o) && o !== r && Lt(e, o, { get: () => t[o], enumerable: !(i = Ws(t, o)) || i.enumerable });
  return e;
};
var ia = (e, t, r) => (r = e != null ? Ks(ta(e)) : {}, ra(t || !e || !e.__esModule ? Lt(r, "default", { value: e, enumerable: true }) : r, e));
var Pr = (e, t, r) => new Promise((i, o) => {
  var n = (l) => {
    try {
      a(r.next(l));
    } catch (c) {
      o(c);
    }
  }, s = (l) => {
    try {
      a(r.throw(l));
    } catch (c) {
      o(c);
    }
  }, a = (l) => l.done ? i(l.value) : Promise.resolve(l.value).then(n, s);
  a((r = r.apply(e, t)).next());
});
var Ls = ot((ng, As) => {
  "use strict";
  As.exports = (e) => encodeURIComponent(e).replace(/[!'()*]/g, (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`);
});
var Ms = ot((sg, Is) => {
  "use strict";
  var Ds = "%[a-f0-9]{2}", Os = new RegExp("(" + Ds + ")|([^%]+?)", "gi"), Fs = new RegExp("(" + Ds + ")+", "gi");
  function Li(e, t) {
    try {
      return [decodeURIComponent(e.join(""))];
    } catch {
    }
    if (e.length === 1) return e;
    t = t || 1;
    var r = e.slice(0, t), i = e.slice(t);
    return Array.prototype.concat.call([], Li(r), Li(i));
  }
  function Xl(e) {
    try {
      return decodeURIComponent(e);
    } catch {
      for (var t = e.match(Os) || [], r = 1; r < t.length; r++) e = Li(t, r).join(""), t = e.match(Os) || [];
      return e;
    }
  }
  function Zl(e) {
    for (var t = { "%FE%FF": "\uFFFD\uFFFD", "%FF%FE": "\uFFFD\uFFFD" }, r = Fs.exec(e); r; ) {
      try {
        t[r[0]] = decodeURIComponent(r[0]);
      } catch {
        var i = Xl(r[0]);
        i !== r[0] && (t[r[0]] = i);
      }
      r = Fs.exec(e);
    }
    t["%C2"] = "\uFFFD";
    for (var o = Object.keys(t), n = 0; n < o.length; n++) {
      var s = o[n];
      e = e.replace(new RegExp(s, "g"), t[s]);
    }
    return e;
  }
  Is.exports = function(e) {
    if (typeof e != "string") throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof e + "`");
    try {
      return e = e.replace(/\+/g, " "), decodeURIComponent(e);
    } catch {
      return Zl(e);
    }
  };
});
var Us = ot((ag, Ns) => {
  "use strict";
  Ns.exports = (e, t) => {
    if (!(typeof e == "string" && typeof t == "string")) throw new TypeError("Expected the arguments to be of type `string`");
    if (t === "") return [e];
    let r = e.indexOf(t);
    return r === -1 ? [e] : [e.slice(0, r), e.slice(r + t.length)];
  };
});
var Bs = ot((cg, Hs) => {
  "use strict";
  Hs.exports = function(e, t) {
    for (var r = {}, i = Object.keys(e), o = Array.isArray(t), n = 0; n < i.length; n++) {
      var s = i[n], a = e[s];
      (o ? t.indexOf(s) !== -1 : t(s, a, e)) && (r[s] = a);
    }
    return r;
  };
});
var Zs = ot((te) => {
  "use strict";
  var Ql = Ls(), Kl = Ms(), ks = Us(), $l = Bs(), Wl = (e) => e == null, Oi = Symbol("encodeFragmentIdentifier");
  function Jl(e) {
    switch (e.arrayFormat) {
      case "index":
        return (t) => (r, i) => {
          let o = r.length;
          return i === void 0 || e.skipNull && i === null || e.skipEmptyString && i === "" ? r : i === null ? [...r, [q(t, e), "[", o, "]"].join("")] : [...r, [q(t, e), "[", q(o, e), "]=", q(i, e)].join("")];
        };
      case "bracket":
        return (t) => (r, i) => i === void 0 || e.skipNull && i === null || e.skipEmptyString && i === "" ? r : i === null ? [...r, [q(t, e), "[]"].join("")] : [...r, [q(t, e), "[]=", q(i, e)].join("")];
      case "colon-list-separator":
        return (t) => (r, i) => i === void 0 || e.skipNull && i === null || e.skipEmptyString && i === "" ? r : i === null ? [...r, [q(t, e), ":list="].join("")] : [...r, [q(t, e), ":list=", q(i, e)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        let t = e.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (r) => (i, o) => o === void 0 || e.skipNull && o === null || e.skipEmptyString && o === "" ? i : (o = o === null ? "" : o, i.length === 0 ? [[q(r, e), t, q(o, e)].join("")] : [[i, q(o, e)].join(e.arrayFormatSeparator)]);
      }
      default:
        return (t) => (r, i) => i === void 0 || e.skipNull && i === null || e.skipEmptyString && i === "" ? r : i === null ? [...r, q(t, e)] : [...r, [q(t, e), "=", q(i, e)].join("")];
    }
  }
  function ef(e) {
    let t;
    switch (e.arrayFormat) {
      case "index":
        return (r, i, o) => {
          if (t = /\[(\d*)\]$/.exec(r), r = r.replace(/\[\d*\]$/, ""), !t) {
            o[r] = i;
            return;
          }
          o[r] === void 0 && (o[r] = {}), o[r][t[1]] = i;
        };
      case "bracket":
        return (r, i, o) => {
          if (t = /(\[\])$/.exec(r), r = r.replace(/\[\]$/, ""), !t) {
            o[r] = i;
            return;
          }
          if (o[r] === void 0) {
            o[r] = [i];
            return;
          }
          o[r] = [].concat(o[r], i);
        };
      case "colon-list-separator":
        return (r, i, o) => {
          if (t = /(:list)$/.exec(r), r = r.replace(/:list$/, ""), !t) {
            o[r] = i;
            return;
          }
          if (o[r] === void 0) {
            o[r] = [i];
            return;
          }
          o[r] = [].concat(o[r], i);
        };
      case "comma":
      case "separator":
        return (r, i, o) => {
          let n = typeof i == "string" && i.includes(e.arrayFormatSeparator), s = typeof i == "string" && !n && be(i, e).includes(e.arrayFormatSeparator);
          i = s ? be(i, e) : i;
          let a = n || s ? i.split(e.arrayFormatSeparator).map((l) => be(l, e)) : i === null ? i : be(i, e);
          o[r] = a;
        };
      case "bracket-separator":
        return (r, i, o) => {
          let n = /(\[\])$/.test(r);
          if (r = r.replace(/\[\]$/, ""), !n) {
            o[r] = i && be(i, e);
            return;
          }
          let s = i === null ? [] : i.split(e.arrayFormatSeparator).map((a) => be(a, e));
          if (o[r] === void 0) {
            o[r] = s;
            return;
          }
          o[r] = [].concat(o[r], s);
        };
      default:
        return (r, i, o) => {
          if (o[r] === void 0) {
            o[r] = i;
            return;
          }
          o[r] = [].concat(o[r], i);
        };
    }
  }
  function Gs(e) {
    if (typeof e != "string" || e.length !== 1) throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function q(e, t) {
    return t.encode ? t.strict ? Ql(e) : encodeURIComponent(e) : e;
  }
  function be(e, t) {
    return t.decode ? Kl(e) : e;
  }
  function Ys(e) {
    return Array.isArray(e) ? e.sort() : typeof e == "object" ? Ys(Object.keys(e)).sort((t, r) => Number(t) - Number(r)).map((t) => e[t]) : e;
  }
  function qs(e) {
    let t = e.indexOf("#");
    return t !== -1 && (e = e.slice(0, t)), e;
  }
  function tf(e) {
    let t = "", r = e.indexOf("#");
    return r !== -1 && (t = e.slice(r)), t;
  }
  function js(e) {
    e = qs(e);
    let t = e.indexOf("?");
    return t === -1 ? "" : e.slice(t + 1);
  }
  function Vs(e, t) {
    return t.parseNumbers && !Number.isNaN(Number(e)) && typeof e == "string" && e.trim() !== "" ? e = Number(e) : t.parseBooleans && e !== null && (e.toLowerCase() === "true" || e.toLowerCase() === "false") && (e = e.toLowerCase() === "true"), e;
  }
  function Xs(e, t) {
    t = Object.assign({ decode: true, sort: true, arrayFormat: "none", arrayFormatSeparator: ",", parseNumbers: false, parseBooleans: false }, t), Gs(t.arrayFormatSeparator);
    let r = ef(t), i = /* @__PURE__ */ Object.create(null);
    if (typeof e != "string" || (e = e.trim().replace(/^[?#&]/, ""), !e)) return i;
    for (let o of e.split("&")) {
      if (o === "") continue;
      let [n, s] = ks(t.decode ? o.replace(/\+/g, " ") : o, "=");
      s = s === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(t.arrayFormat) ? s : be(s, t), r(be(n, t), s, i);
    }
    for (let o of Object.keys(i)) {
      let n = i[o];
      if (typeof n == "object" && n !== null) for (let s of Object.keys(n)) n[s] = Vs(n[s], t);
      else i[o] = Vs(n, t);
    }
    return t.sort === false ? i : (t.sort === true ? Object.keys(i).sort() : Object.keys(i).sort(t.sort)).reduce((o, n) => {
      let s = i[n];
      return Boolean(s) && typeof s == "object" && !Array.isArray(s) ? o[n] = Ys(s) : o[n] = s, o;
    }, /* @__PURE__ */ Object.create(null));
  }
  te.extract = js;
  te.parse = Xs;
  te.stringify = (e, t) => {
    if (!e) return "";
    t = Object.assign({ encode: true, strict: true, arrayFormat: "none", arrayFormatSeparator: "," }, t), Gs(t.arrayFormatSeparator);
    let r = (s) => t.skipNull && Wl(e[s]) || t.skipEmptyString && e[s] === "", i = Jl(t), o = {};
    for (let s of Object.keys(e)) r(s) || (o[s] = e[s]);
    let n = Object.keys(o);
    return t.sort !== false && n.sort(t.sort), n.map((s) => {
      let a = e[s];
      return a === void 0 ? "" : a === null ? q(s, t) : Array.isArray(a) ? a.length === 0 && t.arrayFormat === "bracket-separator" ? q(s, t) + "[]" : a.reduce(i(s), []).join("&") : q(s, t) + "=" + q(a, t);
    }).filter((s) => s.length > 0).join("&");
  };
  te.parseUrl = (e, t) => {
    t = Object.assign({ decode: true }, t);
    let [r, i] = ks(e, "#");
    return Object.assign({ url: r.split("?")[0] || "", query: Xs(js(e), t) }, t && t.parseFragmentIdentifier && i ? { fragmentIdentifier: be(i, t) } : {});
  };
  te.stringifyUrl = (e, t) => {
    t = Object.assign({ encode: true, strict: true, [Oi]: true }, t);
    let r = qs(e.url).split("?")[0] || "", i = te.extract(e.url), o = te.parse(i, { sort: false }), n = Object.assign(o, e.query), s = te.stringify(n, t);
    s && (s = `?${s}`);
    let a = tf(e.url);
    return e.fragmentIdentifier && (a = `#${t[Oi] ? q(e.fragmentIdentifier, t) : e.fragmentIdentifier}`), `${r}${s}${a}`;
  };
  te.pick = (e, t, r) => {
    r = Object.assign({ parseFragmentIdentifier: true, [Oi]: false }, r);
    let { url: i, query: o, fragmentIdentifier: n } = te.parseUrl(e, r);
    return te.stringifyUrl({ url: i, query: $l(o, t), fragmentIdentifier: n }, r);
  };
  te.exclude = (e, t, r) => {
    let i = Array.isArray(t) ? (o) => !t.includes(o) : (o, n) => !t(o, n);
    return te.pick(e, i, r);
  };
});
var Hi = (e, t) => ({ dpr: e, camera: { fov: t }, linear: true, flat: true, gl: { preserveDrawingBuffer: true } });
function Bi() {
  let [e, t] = oa(-1);
  return [e, (i) => {
    let o = i.gl.domElement, n = (l) => {
      l.preventDefault(), t(1), console.log("[Context Lost]");
    }, s = (l) => {
      t(0), console.log("[Context Restored]");
    }, a = (l) => {
      t(2), console.log("[Context Error]");
    };
    return o.addEventListener("webglcontextlost", n), o.addEventListener("webglcontextrestored", s), o.addEventListener("webglcontextcreationerror", a), () => {
      o.removeEventListener("webglcontextlost", n), o.removeEventListener("webglcontextrestored", s), o.removeEventListener("webglcontextcreationerror", a);
    };
  }];
}
function ki({ title: e = "", color1: t = "#ff7e5f", color2: r = "#feb47b" }) {
  return Vi("div", { style: { width: "100%", height: "100%", display: "flex", justifyContent: "center", alignItems: "center", background: `linear-gradient(to right, ${t}, ${r})`, color: "white", fontSize: "20px", textAlign: "center", padding: "20px", fontFamily: "Inter", fontWeight: "500" }, children: Vi("p", { children: e }) });
}
function gf(n) {
  var s = n, { children: e, pointerEvents: t = "none", pixelDensity: r = 1, fov: i = 45 } = s, o = J(s, ["children", "pointerEvents", "pixelDensity", "fov"]);
  let [a, l] = Bi();
  return a === 1 ? Cr(ki, { title: "The graphics context has been lost. Please wait while we try to restore it..." }) : Cr(sa, { children: Cr(na, W(M(W(M({ id: "gradientCanvas", resize: { offsetSize: true } }, Hi(r, i)), { style: { pointerEvents: t }, onCreated: l }), o), { children: e }), r + i) });
}
var ge = class {
  constructor() {
    this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
};
var fa = new ca(-1, 1, 1, -1, 0, 1);
var Rr = new aa();
Rr.setAttribute("position", new Gi([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
Rr.setAttribute("uv", new Gi([0, 2, 0, 0, 2, 0], 2));
var Ot = class {
  constructor(t) {
    this._mesh = new la(Rr, t);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(t) {
    t.render(this._mesh, fa);
  }
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
};
var nt = class extends ge {
  constructor(t, r) {
    super(), this.scene = t, this.camera = r, this.clear = true, this.needsSwap = false, this.inverse = false;
  }
  render(t, r, i) {
    let o = t.getContext(), n = t.state;
    n.buffers.color.setMask(false), n.buffers.depth.setMask(false), n.buffers.color.setLocked(true), n.buffers.depth.setLocked(true);
    let s, a;
    this.inverse ? (s = 0, a = 1) : (s = 1, a = 0), n.buffers.stencil.setTest(true), n.buffers.stencil.setOp(o.REPLACE, o.REPLACE, o.REPLACE), n.buffers.stencil.setFunc(o.ALWAYS, s, 4294967295), n.buffers.stencil.setClear(a), n.buffers.stencil.setLocked(true), t.setRenderTarget(i), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(r), this.clear && t.clear(), t.render(this.scene, this.camera), n.buffers.color.setLocked(false), n.buffers.depth.setLocked(false), n.buffers.stencil.setLocked(false), n.buffers.stencil.setFunc(o.EQUAL, 1, 4294967295), n.buffers.stencil.setOp(o.KEEP, o.KEEP, o.KEEP), n.buffers.stencil.setLocked(true);
  }
};
var Ft = class extends ge {
  constructor() {
    super(), this.needsSwap = false;
  }
  render(t) {
    t.state.buffers.stencil.setLocked(false), t.state.buffers.stencil.setTest(false);
  }
};
var st = class extends ge {
  constructor(t, r) {
    super(), this.textureID = r !== void 0 ? r : "tDiffuse", t instanceof Yi ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = ua.clone(t.uniforms), this.material = new Yi({ defines: Object.assign({}, t.defines), uniforms: this.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader })), this.fsQuad = new Ot(this.material);
  }
  render(t, r, i) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(r), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t));
  }
};
var wr = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}` };
var Dt = class {
  constructor(t, r) {
    if (this.renderer = t, r === void 0) {
      let i = { minFilter: qi, magFilter: qi, format: pa }, o = t.getSize(new ji());
      this._pixelRatio = t.getPixelRatio(), this._width = o.width, this._height = o.height, r = new ga(this._width * this._pixelRatio, this._height * this._pixelRatio, i), r.texture.name = "EffectComposer.rt1";
    } else this._pixelRatio = 1, this._width = r.width, this._height = r.height;
    this.renderTarget1 = r, this.renderTarget2 = r.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], wr === void 0 && console.error("THREE.EffectComposer relies on CopyShader"), st === void 0 && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new st(wr), this.clock = new ma();
  }
  swapBuffers() {
    let t = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = t;
  }
  addPass(t) {
    this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(t, r) {
    this.passes.splice(r, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(t) {
    let r = this.passes.indexOf(t);
    r !== -1 && this.passes.splice(r, 1);
  }
  isLastEnabledPass(t) {
    for (let r = t + 1; r < this.passes.length; r++) if (this.passes[r].enabled) return false;
    return true;
  }
  render(t) {
    t === void 0 && (t = this.clock.getDelta());
    let r = this.renderer.getRenderTarget(), i = false;
    for (let o = 0, n = this.passes.length; o < n; o++) {
      let s = this.passes[o];
      if (s.enabled !== false) {
        if (s.renderToScreen = this.renderToScreen && this.isLastEnabledPass(o), s.render(this.renderer, this.writeBuffer, this.readBuffer, t, i), s.needsSwap) {
          if (i) {
            let a = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
            l.setFunc(a.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), l.setFunc(a.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        nt !== void 0 && (s instanceof nt ? i = true : s instanceof Ft && (i = false));
      }
    }
    this.renderer.setRenderTarget(r);
  }
  reset(t) {
    if (t === void 0) {
      let r = this.renderer.getSize(new ji());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = r.width, this._height = r.height, t = this.renderTarget1.clone(), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(t, r) {
    this._width = t, this._height = r;
    let i = this._width * this._pixelRatio, o = this._height * this._pixelRatio;
    this.renderTarget1.setSize(i, o), this.renderTarget2.setSize(i, o);
    for (let n = 0; n < this.passes.length; n++) this.passes[n].setSize(i, o);
  }
  setPixelRatio(t) {
    this._pixelRatio = t, this.setSize(this._width, this._height);
  }
};
var Df = new ha(-1, 1, 1, -1, 0, 1);
var Zi = new da();
Zi.setAttribute("position", new Xi([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
Zi.setAttribute("uv", new Xi([0, 2, 0, 0, 2, 0], 2));
var It = class extends ge {
  constructor(t, r, i, o, n) {
    super(), this.scene = t, this.camera = r, this.overrideMaterial = i, this.clearColor = o, this.clearAlpha = n !== void 0 ? n : 0, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new va();
  }
  render(t, r, i) {
    let o = t.autoClear;
    t.autoClear = false;
    let n, s;
    this.overrideMaterial !== void 0 && (s = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (t.getClearColor(this._oldClearColor), n = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : i), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(this._oldClearColor, n), this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = s), t.autoClear = o;
  }
};
var G = { SKIP: 0, ADD: 1, ALPHA: 2, AVERAGE: 3, COLOR_BURN: 4, COLOR_DODGE: 5, DARKEN: 6, DIFFERENCE: 7, EXCLUSION: 8, LIGHTEN: 9, MULTIPLY: 10, DIVIDE: 11, NEGATION: 12, NORMAL: 13, OVERLAY: 14, REFLECT: 15, SCREEN: 16, SOFT_LIGHT: 17, SUBTRACT: 18 };
var Qi = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}";
var Ki = "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}";
var $i = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}";
var Wi = "float blend(const in float x,const in float y){return(y==0.0)?y:max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var Ji = "float blend(const in float x,const in float y){return(y==1.0)?y:min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var eo = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}";
var to = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}";
var ro = "float blend(const in float x,const in float y){return(y>0.0)?min(x/y,1.0):1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var io = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}";
var oo = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}";
var no = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}";
var so = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}";
var ao = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}";
var co = "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var lo = "float blend(const in float x,const in float y){return(y==1.0)?y:min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var fo = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}";
var uo = "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}";
var mo = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}";
var xa = /* @__PURE__ */ new Map([[G.SKIP, null], [G.ADD, Qi], [G.ALPHA, Ki], [G.AVERAGE, $i], [G.COLOR_BURN, Wi], [G.COLOR_DODGE, Ji], [G.DARKEN, eo], [G.DIFFERENCE, to], [G.EXCLUSION, io], [G.LIGHTEN, oo], [G.MULTIPLY, no], [G.DIVIDE, ro], [G.NEGATION, so], [G.NORMAL, ao], [G.OVERLAY, co], [G.REFLECT, lo], [G.SCREEN, fo], [G.SOFT_LIGHT, uo], [G.SUBTRACT, mo]]);
var at = class extends _a {
  constructor(t, r = 1) {
    super(), this.blendFunction = t, this.opacity = new ya(r);
  }
  getBlendFunction() {
    return this.blendFunction;
  }
  setBlendFunction(t) {
    this.blendFunction = t, this.dispatchEvent({ type: "change" });
  }
  getShaderCode() {
    return xa.get(this.blendFunction);
  }
};
var Ae = { uniforms: { tDiffuse: { value: null }, shape: { value: 1 }, radius: { value: 2 }, rotateR: { value: Math.PI / 12 * 1 }, rotateG: { value: Math.PI / 12 * 2 }, rotateB: { value: Math.PI / 12 * 3 }, scatter: { value: 1 }, width: { value: 20 }, height: { value: 20 }, blending: { value: 1 }, blendingMode: { value: 1 }, greyscale: { value: false }, disable: { value: false } }, vertexShader: `

		varying vec2 vUV;
		varying vec3 vPosition;

		void main() {

			vUV = uv;
			vPosition = position;

			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

		}`, fragmentShader: `

		#define SQRT2_MINUS_ONE 0.41421356
		#define SQRT2_HALF_MINUS_ONE 0.20710678
		#define PI2 6.28318531
		#define SHAPE_DOT 1
		#define SHAPE_ELLIPSE 2
		#define SHAPE_LINE 3
		#define SHAPE_SQUARE 4
		#define BLENDING_LINEAR 1
		#define BLENDING_MULTIPLY 2
		#define BLENDING_ADD 3
		#define BLENDING_LIGHTER 4
		#define BLENDING_DARKER 5
		uniform sampler2D tDiffuse;
		uniform float radius;
		uniform float rotateR;
		uniform float rotateG;
		uniform float rotateB;
		uniform float scatter;
		uniform float width;
		uniform float height;
		uniform int shape;
		uniform bool disable;
		uniform float blending;
		uniform int blendingMode;
		varying vec2 vUV;
		varying vec3 vPosition;
		uniform bool greyscale;
		const int samples = 8;

		float blend( float a, float b, float t ) {

		// linear blend
			return a * ( 1.0 - t ) + b * t;

		}

		float hypot( float x, float y ) {

		// vector magnitude
			return sqrt( x * x + y * y );

		}

		float rand( vec2 seed ){

		// get pseudo-random number
			return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );

		}

		float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {

		// apply shape-specific transforms
			float dist = hypot( coord.x - p.x, coord.y - p.y );
			float rad = channel;

			if ( shape == SHAPE_DOT ) {

				rad = pow( abs( rad ), 1.125 ) * rad_max;

			} else if ( shape == SHAPE_ELLIPSE ) {

				rad = pow( abs( rad ), 1.125 ) * rad_max;

				if ( dist != 0.0 ) {
					float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );
					dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;
				}

			} else if ( shape == SHAPE_LINE ) {

				rad = pow( abs( rad ), 1.5) * rad_max;
				float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;
				dist = hypot( normal.x * dot_p, normal.y * dot_p );

			} else if ( shape == SHAPE_SQUARE ) {

				float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;
				float sin_t = abs( sin( theta ) );
				float cos_t = abs( cos( theta ) );
				rad = pow( abs( rad ), 1.4 );
				rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );

			}

			return rad - dist;

		}

		struct Cell {

		// grid sample positions
			vec2 normal;
			vec2 p1;
			vec2 p2;
			vec2 p3;
			vec2 p4;
			float samp2;
			float samp1;
			float samp3;
			float samp4;

		};

		vec4 getSample( vec2 point ) {

		// multi-sampled point
			vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );
			float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;
			float step = PI2 / float( samples );
			// float dist = radius * 0.66;
			float dist = radius * 0.0;

			for ( int i = 0; i < samples; ++i ) {

				float r = base + step * float( i );
				vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );
				tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );

			}

			tex /= float( samples ) + 1.0;
			return tex;

		}

		float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {

		// get colour for given point
			float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;

			if ( channel == 0 ) {

				c.samp1 = getSample( c.p1 ).r;
				c.samp2 = getSample( c.p2 ).r;
				c.samp3 = getSample( c.p3 ).r;
				c.samp4 = getSample( c.p4 ).r;

			} else if (channel == 1) {

				c.samp1 = getSample( c.p1 ).g;
				c.samp2 = getSample( c.p2 ).g;
				c.samp3 = getSample( c.p3 ).g;
				c.samp4 = getSample( c.p4 ).g;

			} else {

				c.samp1 = getSample( c.p1 ).b;
				c.samp3 = getSample( c.p3 ).b;
				c.samp2 = getSample( c.p2 ).b;
				c.samp4 = getSample( c.p4 ).b;

			}

			dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );
			dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );
			dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );
			dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );
			res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;
			// res = 0.0;
			res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;
			res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;
			res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;
			res = clamp( res, 0.0, 1.0 );

			return res;
			// return 2

		}

		Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {

		// get containing cell
			Cell c;

		// calc grid
			vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );
			float threshold = step * 0.5;
			float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );
			float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );
			vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );
			float offset_normal = mod( hypot( offset.x, offset.y ), step );
			float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;
			float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;
			float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );
			float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;
			float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;

		// get closest corner
			c.normal = n;
			c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;
			c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;

		// scatter
			if ( scatter != 0.0 ) {

				float off_mag = scatter * threshold * 0.5;
				float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;
				c.p1.x += cos( off_angle ) * off_mag;
				c.p1.y += sin( off_angle ) * off_mag;

			}

		// find corners
			float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );
			float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );
			c.p2.x = c.p1.x - n.x * normal_step;
			c.p2.y = c.p1.y - n.y * normal_step;
			c.p3.x = c.p1.x + n.y * line_step;
			c.p3.y = c.p1.y - n.x * line_step;
			c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;
			c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;

			return c;

		}

		float blendColour( float a, float b, float t ) {

		// blend colours
			if ( blendingMode == BLENDING_LINEAR ) {
				return blend( a, b, 1.0 - t );
			} else if ( blendingMode == BLENDING_ADD ) {
				return blend( a, min( 1.0, a + b ), t );
			} else if ( blendingMode == BLENDING_MULTIPLY ) {
				return blend( a, max( 0.0, a * b ), t );
			} else if ( blendingMode == BLENDING_LIGHTER ) {
				return blend( a, max( a, b ), t );
			} else if ( blendingMode == BLENDING_DARKER ) {
				return blend( a, min( a, b ), t );
			} else {
				return blend( a, b, 1.0 - t );
			}

		}

		void main() {

			if ( ! disable ) {

		// setup
				vec2 p = vec2( vUV.x * width, vUV.y * height ) - vec2(vPosition.x, vPosition.y) * 3.0; // - position values to remove black borders.
				vec2 origin = vec2( 0, 0 );
				float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;
				// float aa = 0.0;

		// get channel samples
				Cell cell_r = getReferenceCell( p, origin, rotateR, radius );
				Cell cell_g = getReferenceCell( p, origin, rotateG, radius );
				Cell cell_b = getReferenceCell( p, origin, rotateB, radius );
				float r = getDotColour( cell_r, p, 0, rotateR, aa );
				float g = getDotColour( cell_g, p, 1, rotateG, aa );
				float b = getDotColour( cell_b, p, 2, rotateB, aa );

		// blend with original
				vec4 colour = texture2D( tDiffuse, vUV );
				
				// add masking before blendColour
				if (colour.r == 0.0) {
					r = 0.0;
				} else {
					r = blendColour( r, colour.r, blending );
				}

				if (colour.g == 0.0) {
					g = 0.0;
				} else {
					g = blendColour( g, colour.g, blending );
				}

				if (colour.b == 0.0) {
					b = 0.0;
				} else {
					b = blendColour( b, colour.b, blending );
				}
				
				
				

				if ( greyscale ) {
					r = g = b = (r + b + g) / 3.0;
				}

				// add alpha channel to each r, g, b colors
				vec4 vR;
				vec4 vG;
				vec4 vB;
	
				// apply transparent to outside of mesh
				if (r == 0.0 && colour.r == 0.0) {
					vR = vec4( 0, 0, 0, 0 );
				} else {
					vR = vec4( r, 0, 0, 1 );
				}
	
				if (g == 0.0 && colour.g == 0.0) {
					vG = vec4( 0, 0, 0, 0 );
				} else {
					vG = vec4( 0, g, 0, 1 );
				}
	
				if (b == 0.0 && colour.b == 0.0) {
					vB = vec4( 0, 0, 0, 0 );
				} else {
					vB = vec4( 0, 0, b, 1 );
				}

				// gl_FragColor = vec4( r, g, b, 1.0 );
				gl_FragColor = vR + vG + vB;

			} else {

				gl_FragColor = texture2D( tDiffuse, vUV );

			}

		}` };
var Mt = class {
  constructor() {
    this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
};
var Ta = new ba(-1, 1, 1, -1, 0, 1);
var zr = new Ea();
zr.setAttribute("position", new ho([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
zr.setAttribute("uv", new ho([0, 2, 0, 0, 2, 0], 2));
var Nt = class {
  constructor(t) {
    this._mesh = new Sa(zr, t);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(t) {
    t.render(this._mesh, Ta);
  }
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
};
var po = true;
var Ut = class extends Mt {
  constructor(t, r, i) {
    super(), Ae === void 0 && console.error("THREE.HalftonePass requires HalftoneShader"), this.uniforms = Ca.clone(Ae.uniforms), this.material = new Pa({ uniforms: this.uniforms, fragmentShader: Ae.fragmentShader, vertexShader: Ae.vertexShader }), po && (this.uniforms.width.value = t, this.uniforms.height.value = r), this.uniforms.disable.value = i.disable, this.fsQuad = new Nt(this.material), this.blendMode = new at(G.SCREEN), this.extensions = null;
  }
  render(t, r, i) {
    this.material.uniforms.tDiffuse.value = i.texture, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(r), this.clear && t.clear(), this.fsQuad.render(t));
  }
  setSize(t, r) {
    po && (this.uniforms.width.value = t, this.uniforms.height.value = r);
  }
  initialize(t, r, i) {
  }
  addEventListener() {
  }
  getAttributes() {
    return this.attributes;
  }
  getFragmentShader() {
    return Ae.fragmentShader;
  }
  getVertexShader() {
    return Ae.vertexShader;
  }
  update(t, r, i) {
  }
};
function Ar(e) {
  let { gl: t, scene: r, camera: i, size: o } = za(), n = wa(() => {
    let s = new Dt(t);
    s.addPass(new It(r, i));
    let a = { shape: 1, radius: 2, rotateR: Math.PI / 12, rotateB: Math.PI / 12 * 2, rotateG: Math.PI / 12 * 3, scatter: 1, blending: 1, blendingMode: 1, greyscale: false, disable: e }, l = new Ut(o.width, o.height, a);
    return s.addPass(l), s;
  }, [t, r, i, o, e]);
  Ra(() => n == null ? void 0 : n.setSize(o.width, o.height), [n, o]), Aa((s, a) => (t.autoClear = true, void n.render(a)), 1);
}
function La(e) {
  return function(t) {
    e.forEach(function(r) {
      typeof r == "function" ? r(t) : r != null && (r.current = t);
    });
  };
}
var go = La;
function vo(e, t, r) {
  let { gl: i, size: o, viewport: n } = Oa(), s = typeof e == "number" ? e : o.width * n.dpr, a = typeof t == "number" ? t : o.height * n.dpr, y = (typeof e == "number" ? r : e) || {}, { samples: c } = y, g = J(y, ["samples"]), u = Ve.useMemo(() => {
    let m;
    return m = new Le.WebGLRenderTarget(s, a, M({ minFilter: Le.LinearFilter, magFilter: Le.LinearFilter, encoding: i.outputEncoding, type: Le.HalfFloatType }, g)), m.samples = c, m;
  }, []);
  return Ve.useLayoutEffect(() => {
    u.setSize(s, a), c && (u.samples = c);
  }, [c, u, s, a]), Ve.useEffect(() => () => u.dispose(), []), u;
}
var Da = (e) => typeof e == "function";
var yo = ve.forwardRef((a, s) => {
  var l = a, { envMap: e, resolution: t = 256, frames: r = 1 / 0, children: i, makeDefault: o } = l, n = J(l, ["envMap", "resolution", "frames", "children", "makeDefault"]);
  let c = Lr(({ set: h }) => h), g = Lr(({ camera: h }) => h), u = Lr(({ size: h }) => h), y = ve.useRef(null), m = ve.useRef(null), E = vo(t);
  ve.useLayoutEffect(() => {
    n.manual || y.current.updateProjectionMatrix();
  }, [u, n]), ve.useLayoutEffect(() => {
    y.current.updateProjectionMatrix();
  }), ve.useLayoutEffect(() => {
    if (o) {
      let h = g;
      return c(() => ({ camera: y.current })), () => c(() => ({ camera: h }));
    }
  }, [y, o, c]);
  let v = 0, b = null, p = Da(i);
  return Fa((h) => {
    p && (r === 1 / 0 || v < r) && (m.current.visible = false, h.gl.setRenderTarget(E), b = h.scene.background, e && (h.scene.background = e), h.gl.render(h.scene, y.current), h.scene.background = b, h.gl.setRenderTarget(null), m.current.visible = true, v++);
  }), Ma(Ia, { children: [_o("orthographicCamera", W(M({ left: u.width / -2, right: u.width / 2, top: u.height / 2, bottom: u.height / -2, ref: go([y, s]) }, n), { children: !p && i })), _o("group", { ref: m, children: p && i(E.texture) })] });
});
function Eo(e, t) {
  let r = Ha((o) => o.pointer), [i] = xo.useState(() => {
    let o = new Na();
    return t && Ba(o, t, {}), function(n, s) {
      o.setFromCamera(r, e instanceof Ua ? e : e.current);
      let a = this.constructor.prototype.raycast.bind(this);
      a && a(o, s);
    };
  });
  return i;
}
var wo = Y.createContext({});
var zo = () => Y.useContext(wo);
var ja = 2 * Math.PI;
var So = new Ya();
var To = new Ga();
var [Ge, Or] = [new bo(), new bo()];
var Po = new Ht();
var Co = new Ht();
var Xa = (e) => "minPolarAngle" in e;
var Ao = ({ alignment: e = "bottom-right", margin: t = [80, 80], renderPriority: r = 0, autoClear: i = true, onUpdate: o, onTarget: n, children: s }) => {
  let a = ke(({ size: L }) => L), l = ke(({ camera: L }) => L), c = ke(({ controls: L }) => L), g = ke(({ gl: L }) => L), u = ke(({ scene: L }) => L), y = ke(({ invalidate: L }) => L), m = Y.useRef(), E = Y.useRef(), v = Y.useRef(null), [b] = Y.useState(() => new qa()), p = Y.useRef(false), h = Y.useRef(0), T = Y.useRef(new Ht(0, 0, 0)), O = Y.useRef(new Ht(0, 0, 0));
  Y.useEffect(() => {
    O.current.copy(l.up);
  }, [l]);
  let f = Y.useCallback((L) => {
    p.current = true, (c || n) && (T.current = (c == null ? void 0 : c.target) || (n == null ? void 0 : n())), h.current = l.position.distanceTo(Po), Ge.copy(l.quaternion), Co.copy(L).multiplyScalar(h.current).add(Po), So.lookAt(Co), Or.copy(So.quaternion), y();
  }, [c, l, n, y]);
  Y.useEffect(() => (u.background && (m.current = u.background, u.background = null, b.background = m.current), () => {
    m.current && (u.background = m.current);
  }), []), ka((L, N) => {
    var D;
    if (v.current && E.current) {
      if (p.current) if (Ge.angleTo(Or) < 0.01) p.current = false, Xa(c) && l.up.copy(O.current);
      else {
        let k = N * ja;
        Ge.rotateTowards(Or, k), l.position.set(0, 0, 1).applyQuaternion(Ge).multiplyScalar(h.current).add(T.current), l.up.set(0, 1, 0).applyQuaternion(Ge).normalize(), l.quaternion.copy(Ge), o ? o() : c && c.update(), y();
      }
      To.copy(l.matrix).invert(), (D = E.current) == null || D.quaternion.setFromRotationMatrix(To), i && (g.autoClear = false), g.clearDepth(), g.render(b, v.current);
    }
  }, r);
  let C = Eo(v), P = Y.useMemo(() => ({ tweenCamera: f, raycast: C }), [f]), [_, S] = t, R = e.endsWith("-center") ? 0 : e.endsWith("-left") ? -a.width / 2 + _ : a.width / 2 - _, A = e.startsWith("center-") ? 0 : e.startsWith("top-") ? a.height / 2 - S : -a.height / 2 + S;
  return Va(Za(wo.Provider, { value: P, children: [Ro(yo, { ref: v, position: [0, 0, 200] }), Ro("group", { ref: E, position: [R, A, 0], children: s })] }), b);
};
function Fr({ scale: e = [0.8, 0.05, 0.05], color: t, rotation: r }) {
  return Q("group", { rotation: r, children: Bt("mesh", { position: [0.4, 0, 0], children: [Q("boxGeometry", { args: e }), Q("meshBasicMaterial", { color: t, toneMapped: false })] }) });
}
function Ye(l) {
  var c = l, { onClick: e, font: t, disabled: r, arcStyle: i, label: o, labelColor: n, axisHeadScale: s = 1 } = c, a = J(c, ["onClick", "font", "disabled", "arcStyle", "label", "labelColor", "axisHeadScale"]);
  let g = Qa((p) => p.gl), u = Vt.useMemo(() => {
    let p = document.createElement("canvas");
    p.width = 64, p.height = 64;
    let h = p.getContext("2d");
    return h.beginPath(), h.arc(32, 32, 16, 0, 2 * Math.PI), h.closePath(), h.fillStyle = i, h.fill(), o && (h.font = t, h.textAlign = "center", h.fillStyle = n, h.fillText(o, 32, 41)), new Ka(p);
  }, [i, o, n, t]), [y, m] = Vt.useState(false), E = (o ? 1 : 0.75) * (y ? 1.2 : 1) * s;
  return Q("sprite", W(M({ scale: E, onPointerOver: r ? void 0 : (p) => {
    p.stopPropagation(), m(true);
  }, onPointerOut: r ? void 0 : e || ((p) => {
    p.stopPropagation(), m(false);
  }) }, a), { children: Q("spriteMaterial", { map: u, "map-encoding": g.outputEncoding, "map-anisotropy": g.capabilities.getMaxAnisotropy() || 1, alphaTest: 0.3, opacity: o ? 1 : 0.75, toneMapped: false }) }));
}
var Oo = (u) => {
  var y = u, { hideNegativeAxes: e, hideAxisHeads: t, disabled: r, font: i = "18px Inter var, Arial, sans-serif", axisColors: o = ["#ff2060", "#20df80", "#2080ff"], axisHeadScale: n = 1, axisScale: s, labels: a = ["X", "Y", "Z"], labelColor: l = "#000", onClick: c } = y, g = J(y, ["hideNegativeAxes", "hideAxisHeads", "disabled", "font", "axisColors", "axisHeadScale", "axisScale", "labels", "labelColor", "onClick"]);
  let [m, E, v] = o, { tweenCamera: b, raycast: p } = zo(), h = { font: i, disabled: r, labelColor: l, raycast: p, onClick: c, axisHeadScale: n, onPointerDown: r ? void 0 : (T) => {
    b(T.object.position), T.stopPropagation();
  } };
  return Bt("group", W(M({ scale: 40 }, g), { children: [Q(Fr, { color: m, rotation: [0, 0, 0], scale: s }), Q(Fr, { color: E, rotation: [0, 0, Math.PI / 2], scale: s }), Q(Fr, { color: v, rotation: [0, -Math.PI / 2, 0], scale: s }), !t && Bt(Lo, { children: [Q(Ye, M({ arcStyle: m, position: [1, 0, 0], label: a[0] }, h)), Q(Ye, M({ arcStyle: E, position: [0, 1, 0], label: a[1] }, h)), Q(Ye, M({ arcStyle: v, position: [0, 0, 1], label: a[2] }, h)), !e && Bt(Lo, { children: [Q(Ye, M({ arcStyle: m, position: [-1, 0, 0] }, h)), Q(Ye, M({ arcStyle: E, position: [0, -1, 0] }, h)), Q(Ye, M({ arcStyle: v, position: [0, 0, -1] }, h))] })] }), Q("ambientLight", { intensity: 0.5 }), Q("pointLight", { position: [10, 10, 10], intensity: 0.5 })] }));
};
function Fo({ isFigmaPlugin: e }) {
  return Dr($a, { children: Dr(Ao, { alignment: "bottom-right", margin: e ? [25, 25] : [65, 110], renderPriority: 2, children: Dr(Oo, { axisColors: ["#FF430A", "#FF430A", "#FF430A"], labelColor: "white", hideNegativeAxes: true, axisHeadScale: 0.8 }) }) });
}
var X = { LEFT: 1, RIGHT: 2, MIDDLE: 4 };
var x = Object.freeze({ NONE: 0, ROTATE: 1, TRUCK: 2, OFFSET: 4, DOLLY: 8, ZOOM: 16, TOUCH_ROTATE: 32, TOUCH_TRUCK: 64, TOUCH_OFFSET: 128, TOUCH_DOLLY: 256, TOUCH_ZOOM: 512, TOUCH_DOLLY_TRUCK: 1024, TOUCH_DOLLY_OFFSET: 2048, TOUCH_DOLLY_ROTATE: 4096, TOUCH_ZOOM_TRUCK: 8192, TOUCH_ZOOM_OFFSET: 16384, TOUCH_ZOOM_ROTATE: 32768 });
function Oe(e) {
  return e.isPerspectiveCamera;
}
function Se(e) {
  return e.isOrthographicCamera;
}
var qe = Math.PI * 2;
var Do = Math.PI / 2;
var Go = 1e-5;
function V(e, t = Go) {
  return Math.abs(e) < t;
}
function B(e, t, r = Go) {
  return V(e - t, r);
}
function Io(e, t) {
  return Math.round(e / t) * t;
}
function ct(e) {
  return isFinite(e) ? e : e < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function lt(e) {
  return Math.abs(e) < Number.MAX_VALUE ? e : e * (1 / 0);
}
function Ir(e, t) {
  t.set(0, 0), e.forEach((r) => {
    t.x += r.clientX, t.y += r.clientY;
  }), t.x /= e.length, t.y /= e.length;
}
function Mr(e, t) {
  return Se(e) ? (console.warn(`${t} is not supported in OrthographicCamera`), true) : false;
}
function Mo(e) {
  return e.invert ? e.invert() : e.inverse(), e;
}
var Vr = class {
  constructor() {
    this._listeners = {};
  }
  addEventListener(t, r) {
    let i = this._listeners;
    i[t] === void 0 && (i[t] = []), i[t].indexOf(r) === -1 && i[t].push(r);
  }
  hasEventListener(t, r) {
    let i = this._listeners;
    return i[t] !== void 0 && i[t].indexOf(r) !== -1;
  }
  removeEventListener(t, r) {
    let o = this._listeners[t];
    if (o !== void 0) {
      let n = o.indexOf(r);
      n !== -1 && o.splice(n, 1);
    }
  }
  removeAllEventListeners(t) {
    if (!t) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[t]) && (this._listeners[t].length = 0);
  }
  dispatchEvent(t) {
    let i = this._listeners[t.type];
    if (i !== void 0) {
      t.target = this;
      let o = i.slice(0);
      for (let n = 0, s = o.length; n < s; n++) o[n].call(this, t);
    }
  }
};
var Wa = "1.38.1";
var kt = 1 / 8;
var Yo = typeof __unframerWindow < "u";
var Ja = Yo && /Mac/.test(__unframerNavigator.platform);
var No = !(Yo && "PointerEvent" in __unframerWindow);
var z;
var Uo;
var Gt;
var Nr;
var ee;
var I;
var U;
var je;
var fe;
var ue;
var Fe;
var Ho;
var Bo;
var se;
var ft;
var Xe;
var Vo;
var Ur;
var ko;
var Hr;
var Br;
var Yt;
var ut = class extends Vr {
  static install(t) {
    z = t.THREE, Uo = Object.freeze(new z.Vector3(0, 0, 0)), Gt = Object.freeze(new z.Vector3(0, 1, 0)), Nr = Object.freeze(new z.Vector3(0, 0, 1)), ee = new z.Vector2(), I = new z.Vector3(), U = new z.Vector3(), je = new z.Vector3(), fe = new z.Vector3(), ue = new z.Vector3(), Fe = new z.Vector3(), Ho = new z.Vector3(), Bo = new z.Vector3(), se = new z.Spherical(), ft = new z.Spherical(), Xe = new z.Box3(), Vo = new z.Box3(), Ur = new z.Sphere(), ko = new z.Quaternion(), Hr = new z.Quaternion(), Br = new z.Matrix4(), Yt = new z.Raycaster();
  }
  static get ACTION() {
    return x;
  }
  constructor(t, r) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = 0, this.maxDistance = 1 / 0, this.infinityDolly = false, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.dampingFactor = 0.05, this.draggingDampingFactor = 0.25, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.truckSpeed = 2, this.dollyToCursor = false, this.dragToOffset = false, this.verticalDragToForward = false, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = true, this._state = x.NONE, this._viewport = null, this._affectOffset = false, this._dollyControlAmount = 0, this._hasRested = true, this._boundaryEnclosesCamera = false, this._needsUpdate = true, this._updatedLastTime = false, this._elementRect = new DOMRect(), this._activePointers = [], this._truckInternal = (f, C, P) => {
      if (Oe(this._camera)) {
        let _ = I.copy(this._camera.position).sub(this._target), S = this._camera.getEffectiveFOV() * z.MathUtils.DEG2RAD, R = _.length() * Math.tan(S * 0.5), A = this.truckSpeed * f * R / this._elementRect.height, L = this.truckSpeed * C * R / this._elementRect.height;
        this.verticalDragToForward ? (P ? this.setFocalOffset(this._focalOffsetEnd.x + A, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(A, 0, true), this.forward(-L, true)) : P ? this.setFocalOffset(this._focalOffsetEnd.x + A, this._focalOffsetEnd.y + L, this._focalOffsetEnd.z, true) : this.truck(A, L, true);
      } else if (Se(this._camera)) {
        let _ = this._camera, S = f * (_.right - _.left) / _.zoom / this._elementRect.width, R = C * (_.top - _.bottom) / _.zoom / this._elementRect.height;
        P ? this.setFocalOffset(this._focalOffsetEnd.x + S, this._focalOffsetEnd.y + R, this._focalOffsetEnd.z, true) : this.truck(S, R, true);
      }
    }, this._rotateInternal = (f, C) => {
      let P = qe * this.azimuthRotateSpeed * f / this._elementRect.height, _ = qe * this.polarRotateSpeed * C / this._elementRect.height;
      this.rotate(P, _, true);
    }, this._dollyInternal = (f, C, P) => {
      let _ = Math.pow(0.95, -f * this.dollySpeed), S = this._sphericalEnd.radius * _, R = this._sphericalEnd.radius, A = R * (f >= 0 ? -1 : 1);
      this.dollyTo(S), this.infinityDolly && (S < this.minDistance || this.maxDistance === this.minDistance) && (this._camera.getWorldDirection(I), this._targetEnd.add(I.normalize().multiplyScalar(A)), this._target.add(I.normalize().multiplyScalar(A))), this.dollyToCursor && (this._dollyControlAmount += this._sphericalEnd.radius - R, this.infinityDolly && (S < this.minDistance || this.maxDistance === this.minDistance) && (this._dollyControlAmount -= A), this._dollyControlCoord.set(C, P));
    }, this._zoomInternal = (f, C, P) => {
      let _ = Math.pow(0.95, f * this.dollySpeed), S = this._zoomEnd;
      this.zoomTo(this._zoom * _), this.dollyToCursor && (this._dollyControlAmount += this._zoomEnd - S, this._dollyControlCoord.set(C, P));
    }, typeof z > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = t, this._yAxisUpSpace = new z.Quaternion().setFromUnitVectors(this._camera.up, Gt), this._yAxisUpSpaceInverse = Mo(this._yAxisUpSpace.clone()), this._state = x.NONE, this._target = new z.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new z.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new z.Spherical().setFromVector3(I.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._nearPlaneCorners = [new z.Vector3(), new z.Vector3(), new z.Vector3(), new z.Vector3()], this._updateNearPlaneCorners(), this._boundary = new z.Box3(new z.Vector3(-1 / 0, -1 / 0, -1 / 0), new z.Vector3(1 / 0, 1 / 0, 1 / 0)), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlAmount = 0, this._dollyControlCoord = new z.Vector2(), this.mouseButtons = { left: x.ROTATE, middle: x.DOLLY, right: x.TRUCK, wheel: Oe(this._camera) ? x.DOLLY : Se(this._camera) ? x.ZOOM : x.NONE }, this.touches = { one: x.TOUCH_ROTATE, two: Oe(this._camera) ? x.TOUCH_DOLLY_TRUCK : Se(this._camera) ? x.TOUCH_ZOOM_TRUCK : x.NONE, three: x.TOUCH_TRUCK };
    let i = new z.Vector2(), o = new z.Vector2(), n = new z.Vector2(), s = (f) => {
      if (!this._enabled || !this._domElement) return;
      let C = { pointerId: f.pointerId, clientX: f.clientX, clientY: f.clientY, deltaX: 0, deltaY: 0 };
      this._activePointers.push(C), this._domElement.ownerDocument.removeEventListener("pointermove", c, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", y), this._domElement.ownerDocument.addEventListener("pointermove", c, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", y), h(f);
    }, a = (f) => {
      if (!this._enabled || !this._domElement) return;
      let C = { pointerId: 0, clientX: f.clientX, clientY: f.clientY, deltaX: 0, deltaY: 0 };
      this._activePointers.push(C), this._domElement.ownerDocument.removeEventListener("mousemove", g), this._domElement.ownerDocument.removeEventListener("mouseup", m), this._domElement.ownerDocument.addEventListener("mousemove", g), this._domElement.ownerDocument.addEventListener("mouseup", m), h(f);
    }, l = (f) => {
      !this._enabled || !this._domElement || (f.preventDefault(), Array.prototype.forEach.call(f.changedTouches, (C) => {
        let P = { pointerId: C.identifier, clientX: C.clientX, clientY: C.clientY, deltaX: 0, deltaY: 0 };
        this._activePointers.push(P);
      }), this._domElement.ownerDocument.removeEventListener("touchmove", u, { passive: false }), this._domElement.ownerDocument.removeEventListener("touchend", E), this._domElement.ownerDocument.addEventListener("touchmove", u, { passive: false }), this._domElement.ownerDocument.addEventListener("touchend", E), h(f));
    }, c = (f) => {
      f.cancelable && f.preventDefault();
      let C = f.pointerId, P = this._findPointerById(C);
      if (P) {
        if (P.clientX = f.clientX, P.clientY = f.clientY, P.deltaX = f.movementX, P.deltaY = f.movementY, f.pointerType === "touch") switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
        else this._state = 0, (f.buttons & X.LEFT) === X.LEFT && (this._state = this._state | this.mouseButtons.left), (f.buttons & X.MIDDLE) === X.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (f.buttons & X.RIGHT) === X.RIGHT && (this._state = this._state | this.mouseButtons.right);
        T();
      }
    }, g = (f) => {
      let C = this._findPointerById(0);
      C && (C.clientX = f.clientX, C.clientY = f.clientY, C.deltaX = f.movementX, C.deltaY = f.movementY, this._state = 0, (f.buttons & X.LEFT) === X.LEFT && (this._state = this._state | this.mouseButtons.left), (f.buttons & X.MIDDLE) === X.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (f.buttons & X.RIGHT) === X.RIGHT && (this._state = this._state | this.mouseButtons.right), T());
    }, u = (f) => {
      f.cancelable && f.preventDefault(), Array.prototype.forEach.call(f.changedTouches, (C) => {
        let P = C.identifier, _ = this._findPointerById(P);
        _ && (_.clientX = C.clientX, _.clientY = C.clientY);
      }), T();
    }, y = (f) => {
      let C = f.pointerId, P = this._findPointerById(C);
      if (P && this._activePointers.splice(this._activePointers.indexOf(P), 1), f.pointerType === "touch") switch (this._activePointers.length) {
        case 0:
          this._state = x.NONE;
          break;
        case 1:
          this._state = this.touches.one;
          break;
        case 2:
          this._state = this.touches.two;
          break;
        case 3:
          this._state = this.touches.three;
          break;
      }
      else this._state = x.NONE;
      O();
    }, m = () => {
      let f = this._findPointerById(0);
      f && this._activePointers.splice(this._activePointers.indexOf(f), 1), this._state = x.NONE, O();
    }, E = (f) => {
      switch (Array.prototype.forEach.call(f.changedTouches, (C) => {
        let P = C.identifier, _ = this._findPointerById(P);
        _ && this._activePointers.splice(this._activePointers.indexOf(_), 1);
      }), this._activePointers.length) {
        case 0:
          this._state = x.NONE;
          break;
        case 1:
          this._state = this.touches.one;
          break;
        case 2:
          this._state = this.touches.two;
          break;
        case 3:
          this._state = this.touches.three;
          break;
      }
      O();
    }, v = -1, b = (f) => {
      if (!this._enabled || this.mouseButtons.wheel === x.NONE) return;
      if (f.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === x.ROTATE || this.mouseButtons.wheel === x.TRUCK) {
        let R = performance.now();
        v - R < 1e3 && this._getClientRect(this._elementRect), v = R;
      }
      let C = Ja ? -1 : -3, P = f.deltaMode === 1 ? f.deltaY / C : f.deltaY / (C * 10), _ = this.dollyToCursor ? (f.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, S = this.dollyToCursor ? (f.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case x.ROTATE: {
          this._rotateInternal(f.deltaX, f.deltaY);
          break;
        }
        case x.TRUCK: {
          this._truckInternal(f.deltaX, f.deltaY, false);
          break;
        }
        case x.OFFSET: {
          this._truckInternal(f.deltaX, f.deltaY, true);
          break;
        }
        case x.DOLLY: {
          this._dollyInternal(-P, _, S);
          break;
        }
        case x.ZOOM: {
          this._zoomInternal(-P, _, S);
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, p = (f) => {
      this._enabled && f.preventDefault();
    }, h = (f) => {
      if (!this._enabled) return;
      if (Ir(this._activePointers, ee), this._getClientRect(this._elementRect), i.copy(ee), o.copy(ee), this._activePointers.length >= 2) {
        let P = ee.x - this._activePointers[1].clientX, _ = ee.y - this._activePointers[1].clientY, S = Math.sqrt(P * P + _ * _);
        n.set(0, S);
        let R = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, A = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        o.set(R, A);
      }
      if ("touches" in f || "pointerType" in f && f.pointerType === "touch") switch (this._activePointers.length) {
        case 1:
          this._state = this.touches.one;
          break;
        case 2:
          this._state = this.touches.two;
          break;
        case 3:
          this._state = this.touches.three;
          break;
      }
      else this._state = 0, (f.buttons & X.LEFT) === X.LEFT && (this._state = this._state | this.mouseButtons.left), (f.buttons & X.MIDDLE) === X.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (f.buttons & X.RIGHT) === X.RIGHT && (this._state = this._state | this.mouseButtons.right);
      this.dispatchEvent({ type: "controlstart" });
    }, T = () => {
      if (!this._enabled) return;
      Ir(this._activePointers, ee);
      let f = this._domElement && document.pointerLockElement === this._domElement, C = f ? -this._activePointers[0].deltaX : o.x - ee.x, P = f ? -this._activePointers[0].deltaY : o.y - ee.y;
      if (o.copy(ee), ((this._state & x.ROTATE) === x.ROTATE || (this._state & x.TOUCH_ROTATE) === x.TOUCH_ROTATE || (this._state & x.TOUCH_DOLLY_ROTATE) === x.TOUCH_DOLLY_ROTATE || (this._state & x.TOUCH_ZOOM_ROTATE) === x.TOUCH_ZOOM_ROTATE) && this._rotateInternal(C, P), (this._state & x.DOLLY) === x.DOLLY || (this._state & x.ZOOM) === x.ZOOM) {
        let _ = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, S = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & x.DOLLY) === x.DOLLY ? this._dollyInternal(P * kt, _, S) : this._zoomInternal(P * kt, _, S);
      }
      if ((this._state & x.TOUCH_DOLLY) === x.TOUCH_DOLLY || (this._state & x.TOUCH_ZOOM) === x.TOUCH_ZOOM || (this._state & x.TOUCH_DOLLY_TRUCK) === x.TOUCH_DOLLY_TRUCK || (this._state & x.TOUCH_ZOOM_TRUCK) === x.TOUCH_ZOOM_TRUCK || (this._state & x.TOUCH_DOLLY_OFFSET) === x.TOUCH_DOLLY_OFFSET || (this._state & x.TOUCH_ZOOM_OFFSET) === x.TOUCH_ZOOM_OFFSET || (this._state & x.TOUCH_DOLLY_ROTATE) === x.TOUCH_DOLLY_ROTATE || (this._state & x.TOUCH_ZOOM_ROTATE) === x.TOUCH_ZOOM_ROTATE) {
        let _ = ee.x - this._activePointers[1].clientX, S = ee.y - this._activePointers[1].clientY, R = Math.sqrt(_ * _ + S * S), A = n.y - R;
        n.set(0, R);
        let L = this.dollyToCursor ? (o.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, N = this.dollyToCursor ? (o.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & x.TOUCH_DOLLY) === x.TOUCH_DOLLY || (this._state & x.TOUCH_DOLLY_ROTATE) === x.TOUCH_DOLLY_ROTATE || (this._state & x.TOUCH_DOLLY_TRUCK) === x.TOUCH_DOLLY_TRUCK || (this._state & x.TOUCH_DOLLY_OFFSET) === x.TOUCH_DOLLY_OFFSET ? this._dollyInternal(A * kt, L, N) : this._zoomInternal(A * kt, L, N);
      }
      ((this._state & x.TRUCK) === x.TRUCK || (this._state & x.TOUCH_TRUCK) === x.TOUCH_TRUCK || (this._state & x.TOUCH_DOLLY_TRUCK) === x.TOUCH_DOLLY_TRUCK || (this._state & x.TOUCH_ZOOM_TRUCK) === x.TOUCH_ZOOM_TRUCK) && this._truckInternal(C, P, false), ((this._state & x.OFFSET) === x.OFFSET || (this._state & x.TOUCH_OFFSET) === x.TOUCH_OFFSET || (this._state & x.TOUCH_DOLLY_OFFSET) === x.TOUCH_DOLLY_OFFSET || (this._state & x.TOUCH_ZOOM_OFFSET) === x.TOUCH_ZOOM_OFFSET) && this._truckInternal(C, P, true), this.dispatchEvent({ type: "control" });
    }, O = () => {
      Ir(this._activePointers, ee), o.copy(ee), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", c, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", y), this._domElement.ownerDocument.removeEventListener("touchmove", u, { passive: false }), this._domElement.ownerDocument.removeEventListener("touchend", E), this.dispatchEvent({ type: "controlend" }));
    };
    this._addAllEventListeners = (f) => {
      this._domElement = f, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", s), No && this._domElement.addEventListener("mousedown", a), No && this._domElement.addEventListener("touchstart", l), this._domElement.addEventListener("pointercancel", y), this._domElement.addEventListener("wheel", b, { passive: false }), this._domElement.addEventListener("contextmenu", p);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.removeEventListener("pointerdown", s), this._domElement.removeEventListener("mousedown", a), this._domElement.removeEventListener("touchstart", l), this._domElement.removeEventListener("pointercancel", y), this._domElement.removeEventListener("wheel", b, { passive: false }), this._domElement.removeEventListener("contextmenu", p), this._domElement.ownerDocument.removeEventListener("pointermove", c, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", g), this._domElement.ownerDocument.removeEventListener("touchmove", u, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", y), this._domElement.ownerDocument.removeEventListener("mouseup", m), this._domElement.ownerDocument.removeEventListener("touchend", E));
    }, this.cancel = () => {
      this._state !== x.NONE && (this._state = x.NONE, this._activePointers.length = 0, O());
    }, r && this.connect(r), this.update(0);
  }
  get camera() {
    return this._camera;
  }
  set camera(t) {
    this._camera = t, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._domElement && (this._enabled = t, t ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  get active() {
    return !this._hasRested;
  }
  get currentAction() {
    return this._state;
  }
  get distance() {
    return this._spherical.radius;
  }
  set distance(t) {
    this._spherical.radius === t && this._sphericalEnd.radius === t || (this._spherical.radius = t, this._sphericalEnd.radius = t, this._needsUpdate = true);
  }
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(t) {
    this._spherical.theta === t && this._sphericalEnd.theta === t || (this._spherical.theta = t, this._sphericalEnd.theta = t, this._needsUpdate = true);
  }
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(t) {
    this._spherical.phi === t && this._sphericalEnd.phi === t || (this._spherical.phi = t, this._sphericalEnd.phi = t, this._needsUpdate = true);
  }
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(t) {
    this._boundaryEnclosesCamera = t, this._needsUpdate = true;
  }
  addEventListener(t, r) {
    super.addEventListener(t, r);
  }
  removeEventListener(t, r) {
    super.removeEventListener(t, r);
  }
  rotate(t, r, i = false) {
    return this.rotateTo(this._sphericalEnd.theta + t, this._sphericalEnd.phi + r, i);
  }
  rotateAzimuthTo(t, r = false) {
    return this.rotateTo(t, this._sphericalEnd.phi, r);
  }
  rotatePolarTo(t, r = false) {
    return this.rotateTo(this._sphericalEnd.theta, t, r);
  }
  rotateTo(t, r, i = false) {
    let o = z.MathUtils.clamp(t, this.minAzimuthAngle, this.maxAzimuthAngle), n = z.MathUtils.clamp(r, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = o, this._sphericalEnd.phi = n, this._sphericalEnd.makeSafe(), this._needsUpdate = true, i || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    let s = !i || B(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && B(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  dolly(t, r = false) {
    return this.dollyTo(this._sphericalEnd.radius - t, r);
  }
  dollyTo(t, r = false) {
    let i = this._sphericalEnd.radius, o = z.MathUtils.clamp(t, this.minDistance, this.maxDistance);
    if (this.colliderMeshes.length >= 1) {
      let a = this._collisionTest(), l = B(a, this._spherical.radius);
      if (!(i > o) && l) return Promise.resolve();
      this._sphericalEnd.radius = Math.min(o, a);
    } else this._sphericalEnd.radius = o;
    this._needsUpdate = true, r || (this._spherical.radius = this._sphericalEnd.radius);
    let s = !r || B(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  zoom(t, r = false) {
    return this.zoomTo(this._zoomEnd + t, r);
  }
  zoomTo(t, r = false) {
    this._zoomEnd = z.MathUtils.clamp(t, this.minZoom, this.maxZoom), this._needsUpdate = true, r || (this._zoom = this._zoomEnd);
    let i = !r || B(this._zoom, this._zoomEnd, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  pan(t, r, i = false) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(t, r, i);
  }
  truck(t, r, i = false) {
    this._camera.updateMatrix(), fe.setFromMatrixColumn(this._camera.matrix, 0), ue.setFromMatrixColumn(this._camera.matrix, 1), fe.multiplyScalar(t), ue.multiplyScalar(-r);
    let o = I.copy(fe).add(ue), n = U.copy(this._targetEnd).add(o);
    return this.moveTo(n.x, n.y, n.z, i);
  }
  forward(t, r = false) {
    I.setFromMatrixColumn(this._camera.matrix, 0), I.crossVectors(this._camera.up, I), I.multiplyScalar(t);
    let i = U.copy(this._targetEnd).add(I);
    return this.moveTo(i.x, i.y, i.z, r);
  }
  moveTo(t, r, i, o = false) {
    let n = I.set(t, r, i).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, n, this.boundaryFriction), this._needsUpdate = true, o || this._target.copy(this._targetEnd);
    let s = !o || B(this._target.x, this._targetEnd.x, this.restThreshold) && B(this._target.y, this._targetEnd.y, this.restThreshold) && B(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  fitToBox(t, r, { cover: i = false, paddingLeft: o = 0, paddingRight: n = 0, paddingBottom: s = 0, paddingTop: a = 0 } = {}) {
    let l = [], c = t.isBox3 ? Xe.copy(t) : Xe.setFromObject(t);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    let g = Io(this._sphericalEnd.theta, Do), u = Io(this._sphericalEnd.phi, Do);
    l.push(this.rotateTo(g, u, r));
    let y = I.setFromSpherical(this._sphericalEnd).normalize(), m = ko.setFromUnitVectors(y, Nr), E = B(Math.abs(y.y), 1);
    E && m.multiply(Hr.setFromAxisAngle(Gt, g)), m.multiply(this._yAxisUpSpaceInverse);
    let v = Vo.makeEmpty();
    U.copy(c.min).applyQuaternion(m), v.expandByPoint(U), U.copy(c.min).setX(c.max.x).applyQuaternion(m), v.expandByPoint(U), U.copy(c.min).setY(c.max.y).applyQuaternion(m), v.expandByPoint(U), U.copy(c.max).setZ(c.min.z).applyQuaternion(m), v.expandByPoint(U), U.copy(c.min).setZ(c.max.z).applyQuaternion(m), v.expandByPoint(U), U.copy(c.max).setY(c.min.y).applyQuaternion(m), v.expandByPoint(U), U.copy(c.max).setX(c.min.x).applyQuaternion(m), v.expandByPoint(U), U.copy(c.max).applyQuaternion(m), v.expandByPoint(U), v.min.x -= o, v.min.y -= s, v.max.x += n, v.max.y += a, m.setFromUnitVectors(Nr, y), E && m.premultiply(Hr.invert()), m.premultiply(this._yAxisUpSpace);
    let b = v.getSize(I), p = v.getCenter(U).applyQuaternion(m);
    if (Oe(this._camera)) {
      let h = this.getDistanceToFitBox(b.x, b.y, b.z, i);
      l.push(this.moveTo(p.x, p.y, p.z, r)), l.push(this.dollyTo(h, r)), l.push(this.setFocalOffset(0, 0, 0, r));
    } else if (Se(this._camera)) {
      let h = this._camera, T = h.right - h.left, O = h.top - h.bottom, f = i ? Math.max(T / b.x, O / b.y) : Math.min(T / b.x, O / b.y);
      l.push(this.moveTo(p.x, p.y, p.z, r)), l.push(this.zoomTo(f, r)), l.push(this.setFocalOffset(0, 0, 0, r));
    }
    return Promise.all(l);
  }
  fitToSphere(t, r) {
    let i = [], n = t instanceof z.Sphere ? Ur.copy(t) : ec(t, Ur);
    if (i.push(this.moveTo(n.center.x, n.center.y, n.center.z, r)), Oe(this._camera)) {
      let s = this.getDistanceToFitSphere(n.radius);
      i.push(this.dollyTo(s, r));
    } else if (Se(this._camera)) {
      let s = this._camera.right - this._camera.left, a = this._camera.top - this._camera.bottom, l = 2 * n.radius, c = Math.min(s / l, a / l);
      i.push(this.zoomTo(c, r));
    }
    return i.push(this.setFocalOffset(0, 0, 0, r)), Promise.all(i);
  }
  setLookAt(t, r, i, o, n, s, a = false) {
    let l = U.set(o, n, s), c = I.set(t, r, i);
    this._targetEnd.copy(l), this._sphericalEnd.setFromVector3(c.sub(l).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = true, a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    let g = !a || B(this._target.x, this._targetEnd.x, this.restThreshold) && B(this._target.y, this._targetEnd.y, this.restThreshold) && B(this._target.z, this._targetEnd.z, this.restThreshold) && B(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && B(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && B(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(g);
  }
  lerpLookAt(t, r, i, o, n, s, a, l, c, g, u, y, m, E = false) {
    let v = I.set(o, n, s), b = U.set(t, r, i);
    se.setFromVector3(b.sub(v).applyQuaternion(this._yAxisUpSpace));
    let p = je.set(g, u, y), h = U.set(a, l, c);
    ft.setFromVector3(h.sub(p).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(v.lerp(p, m));
    let T = ft.theta - se.theta, O = ft.phi - se.phi, f = ft.radius - se.radius;
    this._sphericalEnd.set(se.radius + f * m, se.phi + O * m, se.theta + T * m), this.normalizeRotations(), this._needsUpdate = true, E || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    let C = !E || B(this._target.x, this._targetEnd.x, this.restThreshold) && B(this._target.y, this._targetEnd.y, this.restThreshold) && B(this._target.z, this._targetEnd.z, this.restThreshold) && B(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && B(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && B(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(C);
  }
  setPosition(t, r, i, o = false) {
    return this.setLookAt(t, r, i, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, o);
  }
  setTarget(t, r, i, o = false) {
    let n = this.getPosition(I), s = this.setLookAt(n.x, n.y, n.z, t, r, i, o);
    return this._sphericalEnd.phi = z.MathUtils.clamp(this.polarAngle, this.minPolarAngle, this.maxPolarAngle), s;
  }
  setFocalOffset(t, r, i, o = false) {
    this._focalOffsetEnd.set(t, r, i), this._needsUpdate = true, o || this._focalOffset.copy(this._focalOffsetEnd), this._affectOffset = !V(t) || !V(r) || !V(i);
    let n = !o || B(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && B(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && B(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  setOrbitPoint(t, r, i) {
    this._camera.updateMatrixWorld(), fe.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), ue.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Fe.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    let o = I.set(t, r, i), n = o.distanceTo(this._camera.position), s = o.sub(this._camera.position);
    fe.multiplyScalar(s.x), ue.multiplyScalar(s.y), Fe.multiplyScalar(s.z), I.copy(fe).add(ue).add(Fe), I.z = I.z + n, this.dollyTo(n, false), this.setFocalOffset(-I.x, I.y, -I.z, false), this.moveTo(t, r, i, false);
  }
  setBoundary(t) {
    if (!t) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = true;
      return;
    }
    this._boundary.copy(t), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = true;
  }
  setViewport(t, r, i, o) {
    if (t === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new z.Vector4(), typeof t == "number" ? this._viewport.set(t, r, i, o) : this._viewport.copy(t);
  }
  getDistanceToFitBox(t, r, i, o = false) {
    if (Mr(this._camera, "getDistanceToFitBox")) return this._spherical.radius;
    let n = t / r, s = this._camera.getEffectiveFOV() * z.MathUtils.DEG2RAD, a = this._camera.aspect;
    return ((o ? n > a : n < a) ? r : t / a) * 0.5 / Math.tan(s * 0.5) + i * 0.5;
  }
  getDistanceToFitSphere(t) {
    if (Mr(this._camera, "getDistanceToFitSphere")) return this._spherical.radius;
    let r = this._camera.getEffectiveFOV() * z.MathUtils.DEG2RAD, i = Math.atan(Math.tan(r * 0.5) * this._camera.aspect) * 2, o = 1 < this._camera.aspect ? r : i;
    return t / Math.sin(o * 0.5);
  }
  getTarget(t) {
    return (t && t.isVector3 ? t : new z.Vector3()).copy(this._targetEnd);
  }
  getPosition(t) {
    return (t && t.isVector3 ? t : new z.Vector3()).setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).add(this._targetEnd);
  }
  getFocalOffset(t) {
    return (t && t.isVector3 ? t : new z.Vector3()).copy(this._focalOffsetEnd);
  }
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % qe, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += qe), this._spherical.theta += qe * Math.round((this._sphericalEnd.theta - this._spherical.theta) / qe);
  }
  reset(t = false) {
    let r = [this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, t), this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, t), this.zoomTo(this._zoom0, t)];
    return Promise.all(r);
  }
  saveState() {
    this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Gt), Mo(this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace));
  }
  update(t) {
    let r = this._state === x.NONE ? this.dampingFactor : this.draggingDampingFactor, i = Math.min(r * t * 60, 1), o = this._sphericalEnd.theta - this._spherical.theta, n = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, a = Ho.subVectors(this._targetEnd, this._target), l = Bo.subVectors(this._focalOffsetEnd, this._focalOffset);
    if (!V(o) || !V(n) || !V(s) || !V(a.x) || !V(a.y) || !V(a.z) || !V(l.x) || !V(l.y) || !V(l.z) ? (this._spherical.set(this._spherical.radius + s * i, this._spherical.phi + n * i, this._spherical.theta + o * i), this._target.add(a.multiplyScalar(i)), this._focalOffset.add(l.multiplyScalar(i)), this._needsUpdate = true) : (this._spherical.copy(this._sphericalEnd), this._target.copy(this._targetEnd), this._focalOffset.copy(this._focalOffsetEnd)), this._dollyControlAmount !== 0) {
      if (Oe(this._camera)) {
        let y = this._camera, m = I.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(), E = U.copy(m).cross(y.up).normalize();
        E.lengthSq() === 0 && (E.x = 1);
        let v = je.crossVectors(E, m), b = this._sphericalEnd.radius * Math.tan(y.getEffectiveFOV() * z.MathUtils.DEG2RAD * 0.5), h = (this._sphericalEnd.radius - this._dollyControlAmount - this._sphericalEnd.radius) / this._sphericalEnd.radius, T = I.copy(this._targetEnd).add(E.multiplyScalar(this._dollyControlCoord.x * b * y.aspect)).add(v.multiplyScalar(this._dollyControlCoord.y * b));
        this._targetEnd.lerp(T, h);
      } else if (Se(this._camera)) {
        let y = this._camera, m = I.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (y.near + y.far) / (y.near - y.far)).unproject(y), E = U.set(0, 0, -1).applyQuaternion(y.quaternion), v = je.copy(m).add(E.multiplyScalar(-m.dot(y.up))), p = -(this._zoom - this._dollyControlAmount - this._zoomEnd) / this._zoom, h = I.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(), T = this._targetEnd.dot(h);
        this._targetEnd.lerp(v, p);
        let O = this._targetEnd.dot(h), f = h.multiplyScalar(O - T);
        this._targetEnd.sub(f);
      }
      this._target.copy(this._targetEnd), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._dollyControlAmount = 0;
    }
    let c = this._zoomEnd - this._zoom;
    this._zoom += c * i, this._camera.zoom !== this._zoom && (V(c) && (this._zoom = this._zoomEnd), this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true);
    let g = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, g), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), this._affectOffset && (this._camera.updateMatrixWorld(), fe.setFromMatrixColumn(this._camera.matrix, 0), ue.setFromMatrixColumn(this._camera.matrix, 1), Fe.setFromMatrixColumn(this._camera.matrix, 2), fe.multiplyScalar(this._focalOffset.x), ue.multiplyScalar(-this._focalOffset.y), Fe.multiplyScalar(this._focalOffset.z), I.copy(fe).add(ue).add(Fe), this._camera.position.add(I)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), I.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    let u = this._needsUpdate;
    return u && !this._updatedLastTime ? (this._hasRested = false, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : u ? (this.dispatchEvent({ type: "update" }), V(o, this.restThreshold) && V(n, this.restThreshold) && V(s, this.restThreshold) && V(a.x, this.restThreshold) && V(a.y, this.restThreshold) && V(a.z, this.restThreshold) && V(l.x, this.restThreshold) && V(l.y, this.restThreshold) && V(l.z, this.restThreshold) && V(c, this.restThreshold) && !this._hasRested && (this._hasRested = true, this.dispatchEvent({ type: "rest" }))) : !u && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._updatedLastTime = u, this._needsUpdate = false, u;
  }
  toJSON() {
    return JSON.stringify({ enabled: this._enabled, minDistance: this.minDistance, maxDistance: ct(this.maxDistance), minZoom: this.minZoom, maxZoom: ct(this.maxZoom), minPolarAngle: this.minPolarAngle, maxPolarAngle: ct(this.maxPolarAngle), minAzimuthAngle: ct(this.minAzimuthAngle), maxAzimuthAngle: ct(this.maxAzimuthAngle), dampingFactor: this.dampingFactor, draggingDampingFactor: this.draggingDampingFactor, dollySpeed: this.dollySpeed, truckSpeed: this.truckSpeed, dollyToCursor: this.dollyToCursor, verticalDragToForward: this.verticalDragToForward, target: this._targetEnd.toArray(), position: I.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(), zoom: this._zoomEnd, focalOffset: this._focalOffsetEnd.toArray(), target0: this._target0.toArray(), position0: this._position0.toArray(), zoom0: this._zoom0, focalOffset0: this._focalOffset0.toArray() });
  }
  fromJSON(t, r = false) {
    let i = JSON.parse(t), o = I.fromArray(i.position);
    this.enabled = i.enabled, this.minDistance = i.minDistance, this.maxDistance = lt(i.maxDistance), this.minZoom = i.minZoom, this.maxZoom = lt(i.maxZoom), this.minPolarAngle = i.minPolarAngle, this.maxPolarAngle = lt(i.maxPolarAngle), this.minAzimuthAngle = lt(i.minAzimuthAngle), this.maxAzimuthAngle = lt(i.maxAzimuthAngle), this.dampingFactor = i.dampingFactor, this.draggingDampingFactor = i.draggingDampingFactor, this.dollySpeed = i.dollySpeed, this.truckSpeed = i.truckSpeed, this.dollyToCursor = i.dollyToCursor, this.verticalDragToForward = i.verticalDragToForward, this._target0.fromArray(i.target0), this._position0.fromArray(i.position0), this._zoom0 = i.zoom0, this._focalOffset0.fromArray(i.focalOffset0), this.moveTo(i.target[0], i.target[1], i.target[2], r), se.setFromVector3(o.sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(se.theta, se.phi, r), this.zoomTo(i.zoom, r), this.setFocalOffset(i.focalOffset[0], i.focalOffset[1], i.focalOffset[2], r), this._needsUpdate = true;
  }
  connect(t) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    t.setAttribute("data-camera-controls-version", Wa), this._addAllEventListeners(t);
  }
  disconnect() {
    this._removeAllEventListeners(), this._domElement = void 0;
  }
  dispose() {
    this.disconnect(), this._domElement && "setAttribute" in this._domElement && this._domElement.removeAttribute("data-camera-controls-version");
  }
  _findPointerById(t) {
    let r = null;
    return this._activePointers.some((i) => i.pointerId === t ? (r = i, true) : false), r;
  }
  _encloseToBoundary(t, r, i) {
    let o = r.lengthSq();
    if (o === 0) return t;
    let n = U.copy(r).add(t), a = this._boundary.clampPoint(n, je).sub(n), l = a.lengthSq();
    if (l === 0) return t.add(r);
    if (l === o) return t;
    if (i === 0) return t.add(r).add(a);
    {
      let c = 1 + i * l / r.dot(a);
      return t.add(U.copy(r).multiplyScalar(c)).add(a.multiplyScalar(1 - i));
    }
  }
  _updateNearPlaneCorners() {
    if (Oe(this._camera)) {
      let t = this._camera, r = t.near, i = t.getEffectiveFOV() * z.MathUtils.DEG2RAD, o = Math.tan(i * 0.5) * r, n = o * t.aspect;
      this._nearPlaneCorners[0].set(-n, -o, 0), this._nearPlaneCorners[1].set(n, -o, 0), this._nearPlaneCorners[2].set(n, o, 0), this._nearPlaneCorners[3].set(-n, o, 0);
    } else if (Se(this._camera)) {
      let t = this._camera, r = 1 / t.zoom, i = t.left * r, o = t.right * r, n = t.top * r, s = t.bottom * r;
      this._nearPlaneCorners[0].set(i, n, 0), this._nearPlaneCorners[1].set(o, n, 0), this._nearPlaneCorners[2].set(o, s, 0), this._nearPlaneCorners[3].set(i, s, 0);
    }
  }
  _collisionTest() {
    let t = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Mr(this._camera, "_collisionTest")) return t;
    let i = I.setFromSpherical(this._spherical).divideScalar(this._spherical.radius);
    Br.lookAt(Uo, i, this._camera.up);
    for (let o = 0; o < 4; o++) {
      let n = U.copy(this._nearPlaneCorners[o]);
      n.applyMatrix4(Br);
      let s = je.addVectors(this._target, n);
      Yt.set(s, i), Yt.far = this._spherical.radius + 1;
      let a = Yt.intersectObjects(this.colliderMeshes);
      a.length !== 0 && a[0].distance < t && (t = a[0].distance);
    }
    return t;
  }
  _getClientRect(t) {
    if (!this._domElement) return;
    let r = this._domElement.getBoundingClientRect();
    return t.x = r.left, t.y = r.top, this._viewport ? (t.x += this._viewport.x, t.y += r.height - this._viewport.w - this._viewport.y, t.width = this._viewport.z, t.height = this._viewport.w) : (t.width = r.width, t.height = r.height), t;
  }
  _createOnRestPromise(t) {
    return t ? Promise.resolve() : (this._hasRested = false, this.dispatchEvent({ type: "transitionstart" }), new Promise((r) => {
      let i = () => {
        this.removeEventListener("rest", i), r();
      };
      this.addEventListener("rest", i);
    }));
  }
  _addAllEventListeners(t) {
  }
  _removeAllEventListeners() {
  }
};
function ec(e, t) {
  let r = t, i = r.center;
  Xe.makeEmpty(), e.traverseVisible((n) => {
    n.isMesh && Xe.expandByObject(n);
  }), Xe.getCenter(i);
  let o = 0;
  return e.traverseVisible((n) => {
    if (!n.isMesh) return;
    let s = n, a = s.geometry.clone();
    if (a.applyMatrix4(s.matrixWorld), a.isBufferGeometry) {
      let c = a.attributes.position;
      for (let g = 0, u = c.count; g < u; g++) I.fromBufferAttribute(c, g), o = Math.max(o, i.distanceToSquared(I));
    } else {
      let l = a.attributes.position, c = new z.Vector3();
      for (let g = 0, u = l.count; g < u; g++) c.fromBufferAttribute(l, g), o = Math.max(o, i.distanceToSquared(c));
    }
  }), r.radius = Math.sqrt(o), r;
}
var qo = 1;
var jo = 14;
var kr = { zoom: 1, distance: 14 };
var Gr = { zoom: 5, distance: 14 };
var Xo = { meshDelay: 0, meshDur: 0, rotDelay: 1.7, rotDur: 1, posDelay: 1.3, posDur: 2.2, logoTransition: 3.1, text: 2.5, to: 1 };
var qt = "https://ruucm.github.io/shadergradient/shadergradient@1.0.0/hdr/";
function jt(e) {
  return e / 180 * Math.PI;
}
function Yr(e) {
  return e.map((t) => jt(t));
}
function qr(e) {
  return e.replace("http://localhost:3001/customize", "").replace("https://shadergradient.co/customize", "").replace("https://www.shadergradient.co/customize", "");
}
function Qo({ type: e, cAzimuthAngle: t, cPolarAngle: r, cDistance: i, cameraZoom: o, zoomOut: n }) {
  let s = tc(), a = s.current;
  return rc((l, c) => s.current.update(c)), Zo(() => {
    a == null || a.rotateTo(jt(t), jt(r), true);
  }, [a, t, r]), Zo(() => {
    n ? e === "sphere" ? (a == null || a.dollyTo(Gr.distance, true), a == null || a.zoomTo(Gr.zoom, true)) : (a == null || a.dollyTo(kr.distance, true), a == null || a.zoomTo(kr.zoom, true)) : e === "sphere" ? (a == null || a.zoomTo(o, true), a == null || a.dollyTo(jo, true)) : (a == null || a.dollyTo(i, true), a == null || a.zoomTo(qo, true));
  }, [a, n, e, o, i]), s;
}
function $o(r) {
  var i = r, { dampingFactor: e = 0.05 } = i, t = J(i, ["dampingFactor"]);
  ut.install({ THREE: ic }), oc({ CameraControls: ut });
  let o = Ko((a) => a.camera), n = Ko((a) => a.gl), s = Qo(t);
  return nc("cameraControls", { ref: s, args: [o, n.domElement], enableDamping: true, dampingFactor: e, zoomSpeed: 10, dollySpeed: 10, restThreshold: 0 });
}
var dt = class extends sc {
  constructor(t) {
    super(t), this.type = Xt;
  }
  parse(t) {
    let s = function(_, S) {
      switch (_) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (S || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (S || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (S || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (S || ""));
      }
    }, g = `
`, u = function(_, S, R) {
      S = S || 1024;
      let L = _.pos, N = -1, D = 0, k = "", H = String.fromCharCode.apply(null, new Uint16Array(_.subarray(L, L + 128)));
      for (; 0 > (N = H.indexOf(g)) && D < S && L < _.byteLength; ) k += H, D += H.length, L += 128, H += String.fromCharCode.apply(null, new Uint16Array(_.subarray(L, L + 128)));
      return -1 < N ? (R !== false && (_.pos += D + N + 1), k + H.slice(0, N)) : false;
    }, y = function(_) {
      let S = /^#\?(\S+)/, R = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, A = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, L = /^\s*FORMAT=(\S+)\s*$/, N = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, D = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 }, k, H;
      for ((_.pos >= _.byteLength || !(k = u(_))) && s(1, "no header found"), (H = k.match(S)) || s(3, "bad initial token"), D.valid |= 1, D.programtype = H[1], D.string += k + `
`; k = u(_), k !== false; ) {
        if (D.string += k + `
`, k.charAt(0) === "#") {
          D.comments += k + `
`;
          continue;
        }
        if ((H = k.match(R)) && (D.gamma = parseFloat(H[1])), (H = k.match(A)) && (D.exposure = parseFloat(H[1])), (H = k.match(L)) && (D.valid |= 2, D.format = H[1]), (H = k.match(N)) && (D.valid |= 4, D.height = parseInt(H[1], 10), D.width = parseInt(H[2], 10)), D.valid & 2 && D.valid & 4) break;
      }
      return D.valid & 2 || s(3, "missing format specifier"), D.valid & 4 || s(3, "missing image size specifier"), D;
    }, m = function(_, S, R) {
      let A = S;
      if (A < 8 || A > 32767 || _[0] !== 2 || _[1] !== 2 || _[2] & 128) return new Uint8Array(_);
      A !== (_[2] << 8 | _[3]) && s(3, "wrong scanline width");
      let L = new Uint8Array(4 * S * R);
      L.length || s(4, "unable to allocate buffer space");
      let N = 0, D = 0, k = 4 * A, H = new Uint8Array(4), Be = new Uint8Array(k), Ii = R;
      for (; Ii > 0 && D < _.byteLength; ) {
        D + 4 > _.byteLength && s(1), H[0] = _[D++], H[1] = _[D++], H[2] = _[D++], H[3] = _[D++], (H[0] != 2 || H[1] != 2 || (H[2] << 8 | H[3]) != A) && s(3, "bad rgbe scanline format");
        let it = 0, de;
        for (; it < k && D < _.byteLength; ) {
          de = _[D++];
          let me = de > 128;
          if (me && (de -= 128), (de === 0 || it + de > k) && s(3, "bad scanline data"), me) {
            let he = _[D++];
            for (let Mi = 0; Mi < de; Mi++) Be[it++] = he;
          } else Be.set(_.subarray(D, D + de), it), it += de, D += de;
        }
        let Qs = A;
        for (let me = 0; me < Qs; me++) {
          let he = 0;
          L[N] = Be[me + he], he += A, L[N + 1] = Be[me + he], he += A, L[N + 2] = Be[me + he], he += A, L[N + 3] = Be[me + he], N += 4;
        }
        Ii--;
      }
      return L;
    }, E = function(_, S, R, A) {
      let L = _[S + 3], N = Math.pow(2, L - 128) / 255;
      R[A + 0] = _[S + 0] * N, R[A + 1] = _[S + 1] * N, R[A + 2] = _[S + 2] * N, R[A + 3] = 1;
    }, v = function(_, S, R, A) {
      let L = _[S + 3], N = Math.pow(2, L - 128) / 255;
      R[A + 0] = Zt.toHalfFloat(Math.min(_[S + 0] * N, 65504)), R[A + 1] = Zt.toHalfFloat(Math.min(_[S + 1] * N, 65504)), R[A + 2] = Zt.toHalfFloat(Math.min(_[S + 2] * N, 65504)), R[A + 3] = Zt.toHalfFloat(1);
    }, b = new Uint8Array(t);
    b.pos = 0;
    let p = y(b), h = p.width, T = p.height, O = m(b.subarray(b.pos), h, T), f, C, P;
    switch (this.type) {
      case jr:
        P = O.length / 4;
        let _ = new Float32Array(P * 4);
        for (let R = 0; R < P; R++) E(O, R * 4, _, R * 4);
        f = _, C = jr;
        break;
      case Xt:
        P = O.length / 4;
        let S = new Uint16Array(P * 4);
        for (let R = 0; R < P; R++) v(O, R * 4, S, R * 4);
        f = S, C = Xt;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return { width: h, height: T, data: f, header: p.string, gamma: p.gamma, exposure: p.exposure, type: C };
  }
  setDataType(t) {
    return this.type = t, this;
  }
  load(t, r, i, o) {
    function n(s, a) {
      switch (s.type) {
        case jr:
        case Xt:
          "colorSpace" in s ? s.colorSpace = "srgb-linear" : s.encoding = 3e3, s.minFilter = Wo, s.magFilter = Wo, s.generateMipmaps = false, s.flipY = true;
          break;
      }
      r && r(s, a);
    }
    return super.load(t, n, i, o);
  }
};
function Qt(e, { path: t }) {
  return ac(dt, e, (i) => i.setPath(t));
}
var uc = (e) => e.current && e.current.isScene;
var dc = (e) => uc(e) ? e.current : e;
function Jo({ background: e = false, envPreset: t }) {
  let r = Qt("city.hdr", { path: qt }), i = Qt("dawn.hdr", { path: qt }), o = Qt("lobby.hdr", { path: qt }), s = { city: r, dawn: i, lobby: o }[t], a = fc((c) => c.scene);
  cc.useLayoutEffect(() => {
    if (s) {
      let c = dc(a), g = c.background, u = c.environment;
      return e !== "only" && (c.environment = s), e && (c.background = s), () => {
        e !== "only" && (c.environment = u), e && (c.background = "black");
      };
    }
  }, [a, s, e]);
  let l = s;
  return l.mapping = lc, null;
}
var Xr = 0;
function tn() {
  let [e, t] = mc({});
  return en.onLoad = () => {
    t((r) => W(M({}, r), { active: false }));
  }, en.onProgress = (r, i, o) => {
    i === o && (Xr = o);
    let n = (i - Xr) / (o - Xr) * 100 || 100;
    t((s) => W(M({}, s), { active: true, item: r, loaded: i, total: o, progress: n }));
  }, e;
}
function rn({ lightType: e, brightness: t, envPreset: r }) {
  return _c(vc, { children: [e === "3d" && mt("ambientLight", { intensity: t || 1 }), e === "env" && mt(hc, { fallback: mt(gc, {}), children: mt(Jo, { envPreset: r, background: false, loadingCallback: () => {
  } }) })] });
}
function gc() {
  let { progress: e } = tn();
  return pc(() => {
    let t = document.getElementById("LoaderRoot");
    t && e && (e === 100 ? (t.innerHTML = "Ligths are loaded", setTimeout(() => {
      t.innerHTML = "";
    }, 1e3)) : t.innerHTML = "Loading lights...");
  }, [e]), mt("ambientLight", { intensity: 0.4 });
}
var Qr = pt();
var w = (e) => ht(e, Qr);
var Kr = pt();
w.write = (e) => ht(e, Kr);
var Kt = pt();
w.onStart = (e) => ht(e, Kt);
var $r = pt();
w.onFrame = (e) => ht(e, $r);
var Wr = pt();
w.onFinish = (e) => ht(e, Wr);
var Ze = [];
w.setTimeout = (e, t) => {
  let r = w.now() + t, i = () => {
    let n = Ze.findIndex((s) => s.cancel == i);
    ~n && Ze.splice(n, 1), Pe -= ~n ? 1 : 0;
  }, o = { time: r, handler: e, cancel: i };
  return Ze.splice(on(r), 0, o), Pe += 1, nn(), o;
};
var on = (e) => ~(~Ze.findIndex((t) => t.time > e) || ~Ze.length);
w.cancel = (e) => {
  Kt.delete(e), $r.delete(e), Wr.delete(e), Qr.delete(e), Kr.delete(e);
};
w.sync = (e) => {
  Zr = true, w.batchedUpdates(e), Zr = false;
};
w.throttle = (e) => {
  let t;
  function r() {
    try {
      e(...t);
    } finally {
      t = null;
    }
  }
  function i(...o) {
    t = o, w.onStart(r);
  }
  return i.handler = e, i.cancel = () => {
    Kt.delete(r), t = null;
  }, i;
};
var Jr = typeof __unframerWindow < "u" ? __unframerWindow.requestAnimationFrame : () => {
};
w.use = (e) => Jr = e;
w.now = typeof performance < "u" ? () => performance.now() : Date.now;
w.batchedUpdates = (e) => e();
w.catch = console.error;
w.frameLoop = "always";
w.advance = () => {
  w.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : an();
};
var Te = -1;
var Pe = 0;
var Zr = false;
function ht(e, t) {
  Zr ? (t.delete(e), e(0)) : (t.add(e), nn());
}
function nn() {
  Te < 0 && (Te = 0, w.frameLoop !== "demand" && Jr(sn));
}
function yc() {
  Te = -1;
}
function sn() {
  ~Te && (Jr(sn), w.batchedUpdates(an));
}
function an() {
  let e = Te;
  Te = w.now();
  let t = on(Te);
  if (t && (cn(Ze.splice(0, t), (r) => r.handler()), Pe -= t), !Pe) {
    yc();
    return;
  }
  Kt.flush(), Qr.flush(e ? Math.min(64, Te - e) : 16.667), $r.flush(), Kr.flush(), Wr.flush();
}
function pt() {
  let e = /* @__PURE__ */ new Set(), t = e;
  return { add(r) {
    Pe += t == e && !e.has(r) ? 1 : 0, e.add(r);
  }, delete(r) {
    return Pe -= t == e && e.has(r) ? 1 : 0, e.delete(r);
  }, flush(r) {
    t.size && (e = /* @__PURE__ */ new Set(), Pe -= t.size, cn(t, (i) => i(r) && e.add(i)), Pe += e.size, t = e);
  } };
}
function cn(e, t) {
  e.forEach((r) => {
    try {
      t(r);
    } catch (i) {
      w.catch(i);
    }
  });
}
var xc = Object.defineProperty;
var Ec = (e, t) => {
  for (var r in t) xc(e, r, { get: t[r], enumerable: true });
};
var j = {};
Ec(j, { assign: () => bc, colors: () => Ce, createStringInterpolator: () => ni, skipAnimation: () => yn, to: () => _n, willAdvance: () => si });
function or() {
}
var vn = (e, t, r) => Object.defineProperty(e, t, { value: r, writable: true, configurable: true });
var d = { arr: Array.isArray, obj: (e) => !!e && e.constructor.name === "Object", fun: (e) => typeof e == "function", str: (e) => typeof e == "string", num: (e) => typeof e == "number", und: (e) => e === void 0 };
function ce(e, t) {
  if (d.arr(e)) {
    if (!d.arr(t) || e.length !== t.length) return false;
    for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return false;
    return true;
  }
  return e === t;
}
var F = (e, t) => e.forEach(t);
function $(e, t, r) {
  if (d.arr(e)) {
    for (let i = 0; i < e.length; i++) t.call(r, e[i], `${i}`);
    return;
  }
  for (let i in e) e.hasOwnProperty(i) && t.call(r, e[i], i);
}
var Z = (e) => d.und(e) ? [] : d.arr(e) ? e : [e];
function De(e, t) {
  if (e.size) {
    let r = Array.from(e);
    e.clear(), F(r, t);
  }
}
var Ie = (e, ...t) => De(e, (r) => r(...t));
var oi = () => typeof __unframerWindow > "u" || !__unframerWindow.navigator || /ServerSideRendering|^Deno\//.test(__unframerWindow.navigator.userAgent);
var ni;
var _n;
var Ce = null;
var yn = false;
var si = or;
var bc = (e) => {
  e.to && (_n = e.to), e.now && (w.now = e.now), e.colors !== void 0 && (Ce = e.colors), e.skipAnimation != null && (yn = e.skipAnimation), e.createStringInterpolator && (ni = e.createStringInterpolator), e.requestAnimationFrame && w.use(e.requestAnimationFrame), e.batchedUpdates && (w.batchedUpdates = e.batchedUpdates), e.willAdvance && (si = e.willAdvance), e.frameLoop && (w.frameLoop = e.frameLoop);
};
var gt = /* @__PURE__ */ new Set();
var oe = [];
var ei = [];
var tr = 0;
var _e = { get idle() {
  return !gt.size && !oe.length;
}, start(e) {
  tr > e.priority ? (gt.add(e), w.onStart(Sc)) : (xn(e), w(ii));
}, advance: ii, sort(e) {
  if (tr) w.onFrame(() => _e.sort(e));
  else {
    let t = oe.indexOf(e);
    ~t && (oe.splice(t, 1), En(e));
  }
}, clear() {
  oe = [], gt.clear();
} };
function Sc() {
  gt.forEach(xn), gt.clear(), w(ii);
}
function xn(e) {
  oe.includes(e) || En(e);
}
function En(e) {
  oe.splice(Tc(oe, (t) => t.priority > e.priority), 0, e);
}
function ii(e) {
  let t = ei;
  for (let r = 0; r < oe.length; r++) {
    let i = oe[r];
    tr = i.priority, i.idle || (si(i), i.advance(e), i.idle || t.push(i));
  }
  return tr = 0, ei = oe, ei.length = 0, oe = t, oe.length > 0;
}
function Tc(e, t) {
  let r = e.findIndex(t);
  return r < 0 ? e.length : r;
}
var Pc = (e, t, r) => Math.min(Math.max(r, e), t);
var bn = { transparent: 0, aliceblue: 4042850303, antiquewhite: 4209760255, aqua: 16777215, aquamarine: 2147472639, azure: 4043309055, beige: 4126530815, bisque: 4293182719, black: 255, blanchedalmond: 4293643775, blue: 65535, blueviolet: 2318131967, brown: 2771004159, burlywood: 3736635391, burntsienna: 3934150143, cadetblue: 1604231423, chartreuse: 2147418367, chocolate: 3530104575, coral: 4286533887, cornflowerblue: 1687547391, cornsilk: 4294499583, crimson: 3692313855, cyan: 16777215, darkblue: 35839, darkcyan: 9145343, darkgoldenrod: 3095792639, darkgray: 2846468607, darkgreen: 6553855, darkgrey: 2846468607, darkkhaki: 3182914559, darkmagenta: 2332068863, darkolivegreen: 1433087999, darkorange: 4287365375, darkorchid: 2570243327, darkred: 2332033279, darksalmon: 3918953215, darkseagreen: 2411499519, darkslateblue: 1211993087, darkslategray: 793726975, darkslategrey: 793726975, darkturquoise: 13554175, darkviolet: 2483082239, deeppink: 4279538687, deepskyblue: 12582911, dimgray: 1768516095, dimgrey: 1768516095, dodgerblue: 512819199, firebrick: 2988581631, floralwhite: 4294635775, forestgreen: 579543807, fuchsia: 4278255615, gainsboro: 3705462015, ghostwhite: 4177068031, gold: 4292280575, goldenrod: 3668254975, gray: 2155905279, green: 8388863, greenyellow: 2919182335, grey: 2155905279, honeydew: 4043305215, hotpink: 4285117695, indianred: 3445382399, indigo: 1258324735, ivory: 4294963455, khaki: 4041641215, lavender: 3873897215, lavenderblush: 4293981695, lawngreen: 2096890111, lemonchiffon: 4294626815, lightblue: 2916673279, lightcoral: 4034953471, lightcyan: 3774873599, lightgoldenrodyellow: 4210742015, lightgray: 3553874943, lightgreen: 2431553791, lightgrey: 3553874943, lightpink: 4290167295, lightsalmon: 4288707327, lightseagreen: 548580095, lightskyblue: 2278488831, lightslategray: 2005441023, lightslategrey: 2005441023, lightsteelblue: 2965692159, lightyellow: 4294959359, lime: 16711935, limegreen: 852308735, linen: 4210091775, magenta: 4278255615, maroon: 2147483903, mediumaquamarine: 1724754687, mediumblue: 52735, mediumorchid: 3126187007, mediumpurple: 2473647103, mediumseagreen: 1018393087, mediumslateblue: 2070474495, mediumspringgreen: 16423679, mediumturquoise: 1221709055, mediumvioletred: 3340076543, midnightblue: 421097727, mintcream: 4127193855, mistyrose: 4293190143, moccasin: 4293178879, navajowhite: 4292783615, navy: 33023, oldlace: 4260751103, olive: 2155872511, olivedrab: 1804477439, orange: 4289003775, orangered: 4282712319, orchid: 3664828159, palegoldenrod: 4008225535, palegreen: 2566625535, paleturquoise: 2951671551, palevioletred: 3681588223, papayawhip: 4293907967, peachpuff: 4292524543, peru: 3448061951, pink: 4290825215, plum: 3718307327, powderblue: 2967529215, purple: 2147516671, rebeccapurple: 1714657791, red: 4278190335, rosybrown: 3163525119, royalblue: 1097458175, saddlebrown: 2336560127, salmon: 4202722047, sandybrown: 4104413439, seagreen: 780883967, seashell: 4294307583, sienna: 2689740287, silver: 3233857791, skyblue: 2278484991, slateblue: 1784335871, slategray: 1887473919, slategrey: 1887473919, snow: 4294638335, springgreen: 16744447, steelblue: 1182971135, tan: 3535047935, teal: 8421631, thistle: 3636451583, tomato: 4284696575, turquoise: 1088475391, violet: 4001558271, wheat: 4125012991, white: 4294967295, whitesmoke: 4126537215, yellow: 4294902015, yellowgreen: 2597139199 };
var ae = "[-+]?\\d*\\.?\\d+";
var rr = ae + "%";
function nr(...e) {
  return "\\(\\s*(" + e.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var Cc = new RegExp("rgb" + nr(ae, ae, ae));
var Rc = new RegExp("rgba" + nr(ae, ae, ae, ae));
var wc = new RegExp("hsl" + nr(ae, rr, rr));
var zc = new RegExp("hsla" + nr(ae, rr, rr, ae));
var Ac = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var Lc = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var Oc = /^#([0-9a-fA-F]{6})$/;
var Fc = /^#([0-9a-fA-F]{8})$/;
function Dc(e) {
  let t;
  return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = Oc.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : Ce && Ce[e] !== void 0 ? Ce[e] : (t = Cc.exec(e)) ? (Qe(t[1]) << 24 | Qe(t[2]) << 16 | Qe(t[3]) << 8 | 255) >>> 0 : (t = Rc.exec(e)) ? (Qe(t[1]) << 24 | Qe(t[2]) << 16 | Qe(t[3]) << 8 | un(t[4])) >>> 0 : (t = Ac.exec(e)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + "ff", 16) >>> 0 : (t = Fc.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = Lc.exec(e)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + t[4] + t[4], 16) >>> 0 : (t = wc.exec(e)) ? (ln(fn(t[1]), $t(t[2]), $t(t[3])) | 255) >>> 0 : (t = zc.exec(e)) ? (ln(fn(t[1]), $t(t[2]), $t(t[3])) | un(t[4])) >>> 0 : null;
}
function ti(e, t, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e;
}
function ln(e, t, r) {
  let i = r < 0.5 ? r * (1 + t) : r + t - r * t, o = 2 * r - i, n = ti(o, i, e + 1 / 3), s = ti(o, i, e), a = ti(o, i, e - 1 / 3);
  return Math.round(n * 255) << 24 | Math.round(s * 255) << 16 | Math.round(a * 255) << 8;
}
function Qe(e) {
  let t = parseInt(e, 10);
  return t < 0 ? 0 : t > 255 ? 255 : t;
}
function fn(e) {
  return (parseFloat(e) % 360 + 360) % 360 / 360;
}
function un(e) {
  let t = parseFloat(e);
  return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
}
function $t(e) {
  let t = parseFloat(e);
  return t < 0 ? 0 : t > 100 ? 1 : t / 100;
}
function dn(e) {
  let t = Dc(e);
  if (t === null) return e;
  t = t || 0;
  let r = (t & 4278190080) >>> 24, i = (t & 16711680) >>> 16, o = (t & 65280) >>> 8, n = (t & 255) / 255;
  return `rgba(${r}, ${i}, ${o}, ${n})`;
}
var Re = (e, t, r) => {
  if (d.fun(e)) return e;
  if (d.arr(e)) return Re({ range: e, output: t, extrapolate: r });
  if (d.str(e.output[0])) return ni(e);
  let i = e, o = i.output, n = i.range || [0, 1], s = i.extrapolateLeft || i.extrapolate || "extend", a = i.extrapolateRight || i.extrapolate || "extend", l = i.easing || ((c) => c);
  return (c) => {
    let g = Mc(c, n);
    return Ic(c, n[g], n[g + 1], o[g], o[g + 1], l, s, a, i.map);
  };
};
function Ic(e, t, r, i, o, n, s, a, l) {
  let c = l ? l(e) : e;
  if (c < t) {
    if (s === "identity") return c;
    s === "clamp" && (c = t);
  }
  if (c > r) {
    if (a === "identity") return c;
    a === "clamp" && (c = r);
  }
  return i === o ? i : t === r ? e <= t ? i : o : (t === -1 / 0 ? c = -c : r === 1 / 0 ? c = c - t : c = (c - t) / (r - t), c = n(c), i === -1 / 0 ? c = -c : o === 1 / 0 ? c = c + i : c = c * (o - i) + i, c);
}
function Mc(e, t) {
  for (var r = 1; r < t.length - 1 && !(t[r] >= e); ++r) ;
  return r - 1;
}
var Nc = (e, t = "end") => (r) => {
  r = t === "end" ? Math.min(r, 0.999) : Math.max(r, 1e-3);
  let i = r * e, o = t === "end" ? Math.floor(i) : Math.ceil(i);
  return Pc(0, 1, o / e);
};
var ir = 1.70158;
var Wt = ir * 1.525;
var mn = ir + 1;
var hn = 2 * Math.PI / 3;
var pn = 2 * Math.PI / 4.5;
var Jt = (e) => e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
var ai = { linear: (e) => e, easeInQuad: (e) => e * e, easeOutQuad: (e) => 1 - (1 - e) * (1 - e), easeInOutQuad: (e) => e < 0.5 ? 2 * e * e : 1 - Math.pow(-2 * e + 2, 2) / 2, easeInCubic: (e) => e * e * e, easeOutCubic: (e) => 1 - Math.pow(1 - e, 3), easeInOutCubic: (e) => e < 0.5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2, easeInQuart: (e) => e * e * e * e, easeOutQuart: (e) => 1 - Math.pow(1 - e, 4), easeInOutQuart: (e) => e < 0.5 ? 8 * e * e * e * e : 1 - Math.pow(-2 * e + 2, 4) / 2, easeInQuint: (e) => e * e * e * e * e, easeOutQuint: (e) => 1 - Math.pow(1 - e, 5), easeInOutQuint: (e) => e < 0.5 ? 16 * e * e * e * e * e : 1 - Math.pow(-2 * e + 2, 5) / 2, easeInSine: (e) => 1 - Math.cos(e * Math.PI / 2), easeOutSine: (e) => Math.sin(e * Math.PI / 2), easeInOutSine: (e) => -(Math.cos(Math.PI * e) - 1) / 2, easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * e - 10), easeOutExpo: (e) => e === 1 ? 1 : 1 - Math.pow(2, -10 * e), easeInOutExpo: (e) => e === 0 ? 0 : e === 1 ? 1 : e < 0.5 ? Math.pow(2, 20 * e - 10) / 2 : (2 - Math.pow(2, -20 * e + 10)) / 2, easeInCirc: (e) => 1 - Math.sqrt(1 - Math.pow(e, 2)), easeOutCirc: (e) => Math.sqrt(1 - Math.pow(e - 1, 2)), easeInOutCirc: (e) => e < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * e, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * e + 2, 2)) + 1) / 2, easeInBack: (e) => mn * e * e * e - ir * e * e, easeOutBack: (e) => 1 + mn * Math.pow(e - 1, 3) + ir * Math.pow(e - 1, 2), easeInOutBack: (e) => e < 0.5 ? Math.pow(2 * e, 2) * ((Wt + 1) * 2 * e - Wt) / 2 : (Math.pow(2 * e - 2, 2) * ((Wt + 1) * (e * 2 - 2) + Wt) + 2) / 2, easeInElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : -Math.pow(2, 10 * e - 10) * Math.sin((e * 10 - 10.75) * hn), easeOutElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : Math.pow(2, -10 * e) * Math.sin((e * 10 - 0.75) * hn) + 1, easeInOutElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : e < 0.5 ? -(Math.pow(2, 20 * e - 10) * Math.sin((20 * e - 11.125) * pn)) / 2 : Math.pow(2, -20 * e + 10) * Math.sin((20 * e - 11.125) * pn) / 2 + 1, easeInBounce: (e) => 1 - Jt(1 - e), easeOutBounce: Jt, easeInOutBounce: (e) => e < 0.5 ? (1 - Jt(1 - 2 * e)) / 2 : (1 + Jt(2 * e - 1)) / 2, steps: Nc };
var vt = Symbol.for("FluidValue.get");
var Ke = Symbol.for("FluidValue.observers");
var re = (e) => Boolean(e && e[vt]);
var K = (e) => e && e[vt] ? e[vt]() : e;
var ci = (e) => e[Ke] || null;
function Uc(e, t) {
  e.eventObserved ? e.eventObserved(t) : e(t);
}
function Me(e, t) {
  let r = e[Ke];
  r && r.forEach((i) => {
    Uc(i, t);
  });
}
var Sn = class {
  constructor(e) {
    if (!e && !(e = this.get)) throw Error("Unknown getter");
    Hc(this, e);
  }
};
var Hc = (e, t) => Tn(e, vt, t);
function ye(e, t) {
  if (e[vt]) {
    let r = e[Ke];
    r || Tn(e, Ke, r = /* @__PURE__ */ new Set()), r.has(t) || (r.add(t), e.observerAdded && e.observerAdded(r.size, t));
  }
  return t;
}
function Ne(e, t) {
  let r = e[Ke];
  if (r && r.has(t)) {
    let i = r.size - 1;
    i ? r.delete(t) : e[Ke] = null, e.observerRemoved && e.observerRemoved(i, t);
  }
}
var Tn = (e, t, r) => Object.defineProperty(e, t, { value: r, writable: true, configurable: true });
var er = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var Bc = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var gn = new RegExp(`(${er.source})(%|[a-z]+)`, "i");
var Vc = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var sr = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
var Pn = (e) => {
  let [t, r] = kc(e);
  if (!t || oi()) return e;
  let i = __unframerWindow.getComputedStyle(document.documentElement).getPropertyValue(t);
  if (i) return i.trim();
  if (r && r.startsWith("--")) {
    let o = __unframerWindow.getComputedStyle(document.documentElement).getPropertyValue(r);
    return o || e;
  } else {
    if (r && sr.test(r)) return Pn(r);
    if (r) return r;
  }
  return e;
};
var kc = (e) => {
  let t = sr.exec(e);
  if (!t) return [,];
  let [, r, i] = t;
  return [r, i];
};
var ri;
var Gc = (e, t, r, i, o) => `rgba(${Math.round(t)}, ${Math.round(r)}, ${Math.round(i)}, ${o})`;
var ar = (e) => {
  ri || (ri = Ce ? new RegExp(`(${Object.keys(Ce).join("|")})(?!\\w)`, "g") : /^\b$/);
  let t = e.output.map((n) => K(n).replace(sr, Pn).replace(Bc, dn).replace(ri, dn)), r = t.map((n) => n.match(er).map(Number)), o = r[0].map((n, s) => r.map((a) => {
    if (!(s in a)) throw Error('The arity of each "output" value must be equal');
    return a[s];
  })).map((n) => Re({ ...e, output: n }));
  return (n) => {
    let s = !gn.test(t[0]) && t.find((l) => gn.test(l))?.replace(er, ""), a = 0;
    return t[0].replace(er, () => `${o[a++](n)}${s || ""}`).replace(Vc, Gc);
  };
};
var li = "react-spring: ";
var Cn = (e) => {
  let t = e, r = false;
  if (typeof t != "function") throw new TypeError(`${li}once requires a function parameter`);
  return (...i) => {
    r || (t(...i), r = true);
  };
};
var Yc = Cn(console.warn);
function fi() {
  Yc(`${li}The "interpolate" function is deprecated in v9 (use "to" instead)`);
}
var qc = Cn(console.warn);
function Rn() {
  qc(`${li}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
}
function we(e) {
  return d.str(e) && (e[0] == "#" || /\d/.test(e) || !oi() && sr.test(e) || e in (Ce || {}));
}
var ne = oi() ? Zc : Qc;
var Kc = () => {
  let e = Xc(false);
  return ne(() => (e.current = true, () => {
    e.current = false;
  }), []), e;
};
function _t() {
  let e = jc()[1], t = Kc();
  return () => {
    t.current && e(Math.random());
  };
}
function wn(e, t) {
  let [r] = Jc(() => ({ inputs: t, result: e() })), i = Wc(), o = i.current, n = o;
  return n ? Boolean(t && n.inputs && el(t, n.inputs)) || (n = { inputs: t, result: e() }) : n = r, $c(() => {
    i.current = n, o == r && (r.inputs = r.result = void 0);
  }, [n]), n.result;
}
function el(e, t) {
  if (e.length !== t.length) return false;
  for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return false;
  return true;
}
var $e = (e) => tl(e, rl);
var rl = [];
function cr(e) {
  let t = ol();
  return il(() => {
    t.current = e;
  }), t.current;
}
var yt = Symbol.for("Animated:node");
var nl = (e) => !!e && e[yt] === e;
var ie = (e) => e && e[yt];
var xt = (e, t) => vn(e, yt, t);
var We = (e) => e && e[yt] && e[yt].getPayload();
var Fn = class {
  constructor() {
    xt(this, this);
  }
  getPayload() {
    return this.payload || [];
  }
};
var Je = class extends Fn {
  constructor(e) {
    super(), this._value = e, this.done = true, this.durationProgress = 0, d.num(this._value) && (this.lastPosition = this._value);
  }
  static create(e) {
    return new Je(e);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(e, t) {
    return d.num(e) && (this.lastPosition = e, t && (e = Math.round(e / t) * t, this.done && (this.lastPosition = e))), this._value === e ? false : (this._value = e, true);
  }
  reset() {
    let { done: e } = this;
    this.done = false, d.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null);
  }
};
var et = class extends Je {
  constructor(e) {
    super(0), this._string = null, this._toString = Re({ output: [e, e] });
  }
  static create(e) {
    return new et(e);
  }
  getValue() {
    let e = this._string;
    return e ?? (this._string = this._toString(this._value));
  }
  setValue(e) {
    if (d.str(e)) {
      if (e == this._string) return false;
      this._string = e, this._value = 1;
    } else if (super.setValue(e)) this._string = null;
    else return false;
    return true;
  }
  reset(e) {
    e && (this._toString = Re({ output: [this.getValue(), e] })), this._value = 0, super.reset();
  }
};
var lr = { dependencies: null };
var ui = class extends Fn {
  constructor(e) {
    super(), this.source = e, this.setValue(e);
  }
  getValue(e) {
    let t = {};
    return $(this.source, (r, i) => {
      nl(r) ? t[i] = r.getValue(e) : re(r) ? t[i] = K(r) : e || (t[i] = r);
    }), t;
  }
  setValue(e) {
    this.source = e, this.payload = this._makePayload(e);
  }
  reset() {
    this.payload && F(this.payload, (e) => e.reset());
  }
  _makePayload(e) {
    if (e) {
      let t = /* @__PURE__ */ new Set();
      return $(e, this._addToPayload, t), Array.from(t);
    }
  }
  _addToPayload(e) {
    lr.dependencies && re(e) && lr.dependencies.add(e);
    let t = We(e);
    t && F(t, (r) => this.add(r));
  }
};
var Dn = class extends ui {
  constructor(e) {
    super(e);
  }
  static create(e) {
    return new Dn(e);
  }
  getValue() {
    return this.source.map((e) => e.getValue());
  }
  setValue(e) {
    let t = this.getPayload();
    return e.length == t.length ? t.map((r, i) => r.setValue(e[i])).some(Boolean) : (super.setValue(e.map(sl)), true);
  }
};
function sl(e) {
  return (we(e) ? et : Je).create(e);
}
function Et(e) {
  let t = ie(e);
  return t ? t.constructor : d.arr(e) ? Dn : we(e) ? et : Je;
}
var An = (e, t) => {
  let r = !d.fun(e) || e.prototype && e.prototype.isReactComponent;
  return al((i, o) => {
    let n = zn(null), s = r && cl((E) => {
      n.current = dl(o, E);
    }, [o]), [a, l] = ul(i, t), c = _t(), g = () => {
      let E = n.current;
      if (r && !E) return;
      (E ? t.applyAnimatedValues(E, a.getValue(true)) : false) === false && c();
    }, u = new fl(g, l), y = zn();
    ne(() => (y.current = u, F(l, (E) => ye(E, u)), () => {
      y.current && (F(y.current.deps, (E) => Ne(E, y.current)), w.cancel(y.current.update));
    })), ll(g, []), $e(() => () => {
      let E = y.current;
      F(E.deps, (v) => Ne(v, E));
    });
    let m = t.getComponentProps(a.getValue());
    return In.createElement(e, { ...m, ref: s });
  });
};
var fl = class {
  constructor(e, t) {
    this.update = e, this.deps = t;
  }
  eventObserved(e) {
    e.type == "change" && w.write(this.update);
  }
};
function ul(e, t) {
  let r = /* @__PURE__ */ new Set();
  return lr.dependencies = r, e.style && (e = { ...e, style: t.createAnimatedStyle(e.style) }), e = new ui(e), lr.dependencies = null, [e, r];
}
function dl(e, t) {
  return e && (d.fun(e) ? e(t) : e.current = t), t;
}
var Ln = Symbol.for("AnimatedComponent");
var Mn = (e, { applyAnimatedValues: t = () => false, createAnimatedStyle: r = (o) => new ui(o), getComponentProps: i = (o) => o } = {}) => {
  let o = { applyAnimatedValues: t, createAnimatedStyle: r, getComponentProps: i }, n = (s) => {
    let a = On(s) || "Anonymous";
    return d.str(s) ? s = n[s] || (n[s] = An(s, o)) : s = s[Ln] || (s[Ln] = An(s, o)), s.displayName = `Animated(${a})`, s;
  };
  return $(e, (s, a) => {
    d.arr(e) && (a = On(s)), n[a] = n(s);
  }), { animated: n };
};
var On = (e) => d.str(e) ? e : e && d.str(e.displayName) ? e.displayName : d.fun(e) && e.name || null;
function Ue(e, ...t) {
  return d.fun(e) ? e(...t) : e;
}
var Pt = (e, t) => e === true || !!(t && e && (d.fun(e) ? e(t) : Z(e).includes(t)));
var Zn = (e, t) => d.obj(e) ? t && e[t] : e;
var Qn = (e, t) => e.default === true ? e[t] : e.default ? e.default[t] : void 0;
var ml = (e) => e;
var xi = (e, t = ml) => {
  let r = hl;
  e.default && e.default !== true && (e = e.default, r = Object.keys(e));
  let i = {};
  for (let o of r) {
    let n = t(e[o], o);
    d.und(n) || (i[o] = n);
  }
  return i;
};
var hl = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
var pl = { config: 1, from: 1, to: 1, ref: 1, loop: 1, reset: 1, pause: 1, cancel: 1, reverse: 1, immediate: 1, default: 1, delay: 1, onProps: 1, onStart: 1, onChange: 1, onPause: 1, onResume: 1, onRest: 1, onResolve: 1, items: 1, trail: 1, sort: 1, expires: 1, initial: 1, enter: 1, update: 1, leave: 1, children: 1, onDestroyed: 1, keys: 1, callId: 1, parentId: 1 };
function gl(e) {
  let t = {}, r = 0;
  if ($(e, (i, o) => {
    pl[o] || (t[o] = i, r++);
  }), r) return t;
}
function Kn(e) {
  let t = gl(e);
  if (t) {
    let r = { to: t };
    return $(e, (i, o) => o in t || (r[o] = i)), r;
  }
  return { ...e };
}
function Ct(e) {
  return e = K(e), d.arr(e) ? e.map(Ct) : we(e) ? j.createStringInterpolator({ range: [0, 1], output: [e, e] })(1) : e;
}
function vl(e) {
  for (let t in e) return true;
  return false;
}
function hi(e) {
  return d.fun(e) || d.arr(e) && d.obj(e[0]);
}
function _l(e, t) {
  e.ref?.delete(e), t?.delete(e);
}
function yl(e, t) {
  t && e.ref !== t && (e.ref?.delete(e), t.add(e), e.ref = t);
}
var El = { default: { tension: 170, friction: 26 }, gentle: { tension: 120, friction: 14 }, wobbly: { tension: 180, friction: 12 }, stiff: { tension: 210, friction: 20 }, slow: { tension: 280, friction: 60 }, molasses: { tension: 280, friction: 120 } };
var pi = { ...El.default, mass: 1, damping: 1, easing: ai.linear, clamp: false };
var bl = class {
  constructor() {
    this.velocity = 0, Object.assign(this, pi);
  }
};
function Sl(e, t, r) {
  r && (r = { ...r }, Un(r, t), t = { ...r, ...t }), Un(e, t), Object.assign(e, t);
  for (let s in pi) e[s] == null && (e[s] = pi[s]);
  let { frequency: i, damping: o } = e, { mass: n } = e;
  return d.und(i) || (i < 0.01 && (i = 0.01), o < 0 && (o = 0), e.tension = Math.pow(2 * Math.PI / i, 2) * n, e.friction = 4 * Math.PI * o * n / i), e;
}
function Un(e, t) {
  if (!d.und(t.decay)) e.duration = void 0;
  else {
    let r = !d.und(t.tension) || !d.und(t.friction);
    (r || !d.und(t.frequency) || !d.und(t.damping) || !d.und(t.mass)) && (e.duration = void 0, e.decay = void 0), r && (e.frequency = void 0);
  }
}
var Hn = [];
var Tl = class {
  constructor() {
    this.changed = false, this.values = Hn, this.toValues = null, this.fromValues = Hn, this.config = new bl(), this.immediate = false;
  }
};
function $n(e, { key: t, props: r, defaultProps: i, state: o, actions: n }) {
  return new Promise((s, a) => {
    let l, c, g = Pt(r.cancel ?? i?.cancel, t);
    if (g) m();
    else {
      d.und(r.pause) || (o.paused = Pt(r.pause, t));
      let E = i?.pause;
      E !== true && (E = o.paused || Pt(E, t)), l = Ue(r.delay || 0, t), E ? (o.resumeQueue.add(y), n.pause()) : (n.resume(), y());
    }
    function u() {
      o.resumeQueue.add(y), o.timeouts.delete(c), c.cancel(), l = c.time - w.now();
    }
    function y() {
      l > 0 && !j.skipAnimation ? (o.delayed = true, c = w.setTimeout(m, l), o.pauseQueue.add(u), o.timeouts.add(c)) : m();
    }
    function m() {
      o.delayed && (o.delayed = false), o.pauseQueue.delete(u), o.timeouts.delete(c), e <= (o.cancelId || 0) && (g = true);
      try {
        n.start({ ...r, callId: e, cancel: g }, s);
      } catch (E) {
        a(E);
      }
    }
  });
}
var Ei = (e, t) => t.length == 1 ? t[0] : t.some((r) => r.cancelled) ? tt(e.get()) : t.every((r) => r.noop) ? Wn(e.get()) : le(e.get(), t.every((r) => r.finished));
var Wn = (e) => ({ value: e, noop: true, finished: true, cancelled: false });
var le = (e, t, r = false) => ({ value: e, finished: t, cancelled: r });
var tt = (e) => ({ value: e, cancelled: true, finished: false });
function Jn(e, t, r, i) {
  let { callId: o, parentId: n, onRest: s } = t, { asyncTo: a, promise: l } = r;
  return !n && e === a && !t.reset ? l : r.promise = (async () => {
    r.asyncId = o, r.asyncTo = e;
    let c = xi(t, (b, p) => p === "onRest" ? void 0 : b), g, u, y = new Promise((b, p) => (g = b, u = p)), m = (b) => {
      let p = o <= (r.cancelId || 0) && tt(i) || o !== r.asyncId && le(i, false);
      if (p) throw b.result = p, u(b), b;
    }, E = (b, p) => {
      let h = new Bn(), T = new Vn();
      return (async () => {
        if (j.skipAnimation) throw Rt(r), T.result = le(i, false), u(T), T;
        m(h);
        let O = d.obj(b) ? { ...b } : { ...p, to: b };
        O.parentId = o, $(c, (C, P) => {
          d.und(O[P]) && (O[P] = C);
        });
        let f = await i.start(O);
        return m(h), r.paused && await new Promise((C) => {
          r.resumeQueue.add(C);
        }), f;
      })();
    }, v;
    if (j.skipAnimation) return Rt(r), le(i, false);
    try {
      let b;
      d.arr(e) ? b = (async (p) => {
        for (let h of p) await E(h);
      })(e) : b = Promise.resolve(e(E, i.stop.bind(i))), await Promise.all([b.then(g), y]), v = le(i.get(), true, false);
    } catch (b) {
      if (b instanceof Bn) v = b.result;
      else if (b instanceof Vn) v = b.result;
      else throw b;
    } finally {
      o == r.asyncId && (r.asyncId = n, r.asyncTo = n ? a : void 0, r.promise = n ? l : void 0);
    }
    return d.fun(s) && w.batchedUpdates(() => {
      s(v, i, i.item);
    }), v;
  })();
}
function Rt(e, t) {
  De(e.timeouts, (r) => r.cancel()), e.pauseQueue.clear(), e.resumeQueue.clear(), e.asyncId = e.asyncTo = e.promise = void 0, t && (e.cancelId = t);
}
var Bn = class extends Error {
  constructor() {
    super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
  }
};
var Vn = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
  }
};
var gi = (e) => e instanceof bi;
var Pl = 1;
var bi = class extends Sn {
  constructor() {
    super(...arguments), this.id = Pl++, this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(e) {
    this._priority != e && (this._priority = e, this._onPriorityChange(e));
  }
  get() {
    let e = ie(this);
    return e && e.getValue();
  }
  to(...e) {
    return j.to(this, e);
  }
  interpolate(...e) {
    return fi(), j.to(this, e);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(e) {
    e == 1 && this._attach();
  }
  observerRemoved(e) {
    e == 0 && this._detach();
  }
  _attach() {
  }
  _detach() {
  }
  _onChange(e, t = false) {
    Me(this, { type: "change", parent: this, value: e, idle: t });
  }
  _onPriorityChange(e) {
    this.idle || _e.sort(this), Me(this, { type: "priority", parent: this, priority: e });
  }
};
var He = Symbol.for("SpringPhase");
var es = 1;
var vi = 2;
var _i = 4;
var di = (e) => (e[He] & es) > 0;
var ze = (e) => (e[He] & vi) > 0;
var bt = (e) => (e[He] & _i) > 0;
var kn = (e, t) => t ? e[He] |= vi | es : e[He] &= ~vi;
var Gn = (e, t) => t ? e[He] |= _i : e[He] &= ~_i;
var Cl = class extends bi {
  constructor(e, t) {
    if (super(), this.animation = new Tl(), this.defaultProps = {}, this._state = { paused: false, delayed: false, pauseQueue: /* @__PURE__ */ new Set(), resumeQueue: /* @__PURE__ */ new Set(), timeouts: /* @__PURE__ */ new Set() }, this._pendingCalls = /* @__PURE__ */ new Set(), this._lastCallId = 0, this._lastToId = 0, this._memoizedDuration = 0, !d.und(e) || !d.und(t)) {
      let r = d.obj(e) ? { ...e } : { ...t, from: e };
      d.und(r.default) && (r.default = true), this.start(r);
    }
  }
  get idle() {
    return !(ze(this) || this._state.asyncTo) || bt(this);
  }
  get goal() {
    return K(this.animation.to);
  }
  get velocity() {
    let e = ie(this);
    return e instanceof Je ? e.lastVelocity || 0 : e.getPayload().map((t) => t.lastVelocity || 0);
  }
  get hasAnimated() {
    return di(this);
  }
  get isAnimating() {
    return ze(this);
  }
  get isPaused() {
    return bt(this);
  }
  get isDelayed() {
    return this._state.delayed;
  }
  advance(e) {
    let t = true, r = false, i = this.animation, { toValues: o } = i, { config: n } = i, s = We(i.to);
    !s && re(i.to) && (o = Z(K(i.to))), i.values.forEach((c, g) => {
      if (c.done) return;
      let u = c.constructor == et ? 1 : s ? s[g].lastPosition : o[g], y = i.immediate, m = u;
      if (!y) {
        if (m = c.lastPosition, n.tension <= 0) {
          c.done = true;
          return;
        }
        let E = c.elapsedTime += e, v = i.fromValues[g], b = c.v0 != null ? c.v0 : c.v0 = d.arr(n.velocity) ? n.velocity[g] : n.velocity, p, h = n.precision || (v == u ? 5e-3 : Math.min(1, Math.abs(u - v) * 1e-3));
        if (d.und(n.duration)) if (n.decay) {
          let T = n.decay === true ? 0.998 : n.decay, O = Math.exp(-(1 - T) * E);
          m = v + b / (1 - T) * (1 - O), y = Math.abs(c.lastPosition - m) <= h, p = b * O;
        } else {
          p = c.lastVelocity == null ? b : c.lastVelocity;
          let T = n.restVelocity || h / 10, O = n.clamp ? 0 : n.bounce, f = !d.und(O), C = v == u ? c.v0 > 0 : v < u, P, _ = false, S = 1, R = Math.ceil(e / S);
          for (let A = 0; A < R && (P = Math.abs(p) > T, !(!P && (y = Math.abs(u - m) <= h, y))); ++A) {
            f && (_ = m == u || m > u == C, _ && (p = -p * O, m = u));
            let L = -n.tension * 1e-6 * (m - u), N = -n.friction * 1e-3 * p, D = (L + N) / n.mass;
            p = p + D * S, m = m + p * S;
          }
        }
        else {
          let T = 1;
          n.duration > 0 && (this._memoizedDuration !== n.duration && (this._memoizedDuration = n.duration, c.durationProgress > 0 && (c.elapsedTime = n.duration * c.durationProgress, E = c.elapsedTime += e)), T = (n.progress || 0) + E / this._memoizedDuration, T = T > 1 ? 1 : T < 0 ? 0 : T, c.durationProgress = T), m = v + n.easing(T) * (u - v), p = (m - c.lastPosition) / e, y = T == 1;
        }
        c.lastVelocity = p, Number.isNaN(m) && (console.warn("Got NaN while animating:", this), y = true);
      }
      s && !s[g].done && (y = false), y ? c.done = true : t = false, c.setValue(m, n.round) && (r = true);
    });
    let a = ie(this), l = a.getValue();
    if (t) {
      let c = K(i.to);
      (l !== c || r) && !n.decay ? (a.setValue(c), this._onChange(c)) : r && n.decay && this._onChange(l), this._stop();
    } else r && this._onChange(l);
  }
  set(e) {
    return w.batchedUpdates(() => {
      this._stop(), this._focus(e), this._set(e);
    }), this;
  }
  pause() {
    this._update({ pause: true });
  }
  resume() {
    this._update({ pause: false });
  }
  finish() {
    if (ze(this)) {
      let { to: e, config: t } = this.animation;
      w.batchedUpdates(() => {
        this._onStart(), t.decay || this._set(e, false), this._stop();
      });
    }
    return this;
  }
  update(e) {
    return (this.queue || (this.queue = [])).push(e), this;
  }
  start(e, t) {
    let r;
    return d.und(e) ? (r = this.queue || [], this.queue = []) : r = [d.obj(e) ? e : { ...t, to: e }], Promise.all(r.map((i) => this._update(i))).then((i) => Ei(this, i));
  }
  stop(e) {
    let { to: t } = this.animation;
    return this._focus(this.get()), Rt(this._state, e && this._lastCallId), w.batchedUpdates(() => this._stop(t, e)), this;
  }
  reset() {
    this._update({ reset: true });
  }
  eventObserved(e) {
    e.type == "change" ? this._start() : e.type == "priority" && (this.priority = e.priority + 1);
  }
  _prepareNode(e) {
    let t = this.key || "", { to: r, from: i } = e;
    r = d.obj(r) ? r[t] : r, (r == null || hi(r)) && (r = void 0), i = d.obj(i) ? i[t] : i, i == null && (i = void 0);
    let o = { to: r, from: i };
    return di(this) || (e.reverse && ([r, i] = [i, r]), i = K(i), d.und(i) ? ie(this) || this._set(r) : this._set(i)), o;
  }
  _update({ ...e }, t) {
    let { key: r, defaultProps: i } = this;
    e.default && Object.assign(i, xi(e, (s, a) => /^on/.test(a) ? Zn(s, r) : s)), qn(this, e, "onProps"), Tt(this, "onProps", e, this);
    let o = this._prepareNode(e);
    if (Object.isFrozen(this)) throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
    let n = this._state;
    return $n(++this._lastCallId, { key: r, props: e, defaultProps: i, state: n, actions: { pause: () => {
      bt(this) || (Gn(this, true), Ie(n.pauseQueue), Tt(this, "onPause", le(this, St(this, this.animation.to)), this));
    }, resume: () => {
      bt(this) && (Gn(this, false), ze(this) && this._resume(), Ie(n.resumeQueue), Tt(this, "onResume", le(this, St(this, this.animation.to)), this));
    }, start: this._merge.bind(this, o) } }).then((s) => {
      if (e.loop && s.finished && !(t && s.noop)) {
        let a = ts(e);
        if (a) return this._update(a, true);
      }
      return s;
    });
  }
  _merge(e, t, r) {
    if (t.cancel) return this.stop(true), r(tt(this));
    let i = !d.und(e.to), o = !d.und(e.from);
    if (i || o) if (t.callId > this._lastToId) this._lastToId = t.callId;
    else return r(tt(this));
    let { key: n, defaultProps: s, animation: a } = this, { to: l, from: c } = a, { to: g = l, from: u = c } = e;
    o && !i && (!t.default || d.und(g)) && (g = u), t.reverse && ([g, u] = [u, g]);
    let y = !ce(u, c);
    y && (a.from = u), u = K(u);
    let m = !ce(g, l);
    m && this._focus(g);
    let E = hi(t.to), { config: v } = a, { decay: b, velocity: p } = v;
    (i || o) && (v.velocity = 0), t.config && !E && Sl(v, Ue(t.config, n), t.config !== s.config ? Ue(s.config, n) : void 0);
    let h = ie(this);
    if (!h || d.und(g)) return r(le(this, true));
    let T = d.und(t.reset) ? o && !t.default : !d.und(u) && Pt(t.reset, n), O = T ? u : this.get(), f = Ct(g), C = d.num(f) || d.arr(f) || we(f), P = !E && (!C || Pt(s.immediate || t.immediate, n));
    if (m) {
      let A = Et(g);
      if (A !== h.constructor) if (P) h = this._set(f);
      else throw Error(`Cannot animate between ${h.constructor.name} and ${A.name}, as the "to" prop suggests`);
    }
    let _ = h.constructor, S = re(g), R = false;
    if (!S) {
      let A = T || !di(this) && y;
      (m || A) && (R = ce(Ct(O), f), S = !R), (!ce(a.immediate, P) && !P || !ce(v.decay, b) || !ce(v.velocity, p)) && (S = true);
    }
    if (R && ze(this) && (a.changed && !T ? S = true : S || this._stop(l)), !E && ((S || re(l)) && (a.values = h.getPayload(), a.toValues = re(g) ? null : _ == et ? [1] : Z(f)), a.immediate != P && (a.immediate = P, !P && !T && this._set(l)), S)) {
      let { onRest: A } = a;
      F(wl, (N) => qn(this, t, N));
      let L = le(this, St(this, l));
      Ie(this._pendingCalls, L), this._pendingCalls.add(r), a.changed && w.batchedUpdates(() => {
        a.changed = !T, A?.(L, this), T ? Ue(s.onRest, L) : a.onStart?.(L, this);
      });
    }
    T && this._set(O), E ? r(Jn(t.to, t, this._state, this)) : S ? this._start() : ze(this) && !m ? this._pendingCalls.add(r) : r(Wn(O));
  }
  _focus(e) {
    let t = this.animation;
    e !== t.to && (ci(this) && this._detach(), t.to = e, ci(this) && this._attach());
  }
  _attach() {
    let e = 0, { to: t } = this.animation;
    re(t) && (ye(t, this), gi(t) && (e = t.priority + 1)), this.priority = e;
  }
  _detach() {
    let { to: e } = this.animation;
    re(e) && Ne(e, this);
  }
  _set(e, t = true) {
    let r = K(e);
    if (!d.und(r)) {
      let i = ie(this);
      if (!i || !ce(r, i.getValue())) {
        let o = Et(r);
        !i || i.constructor != o ? xt(this, o.create(r)) : i.setValue(r), i && w.batchedUpdates(() => {
          this._onChange(r, t);
        });
      }
    }
    return ie(this);
  }
  _onStart() {
    let e = this.animation;
    e.changed || (e.changed = true, Tt(this, "onStart", le(this, St(this, e.to)), this));
  }
  _onChange(e, t) {
    t || (this._onStart(), Ue(this.animation.onChange, e, this)), Ue(this.defaultProps.onChange, e, this), super._onChange(e, t);
  }
  _start() {
    let e = this.animation;
    ie(this).reset(K(e.to)), e.immediate || (e.fromValues = e.values.map((t) => t.lastPosition)), ze(this) || (kn(this, true), bt(this) || this._resume());
  }
  _resume() {
    j.skipAnimation ? this.finish() : _e.start(this);
  }
  _stop(e, t) {
    if (ze(this)) {
      kn(this, false);
      let r = this.animation;
      F(r.values, (o) => {
        o.done = true;
      }), r.toValues && (r.onChange = r.onPause = r.onResume = void 0), Me(this, { type: "idle", parent: this });
      let i = t ? tt(this.get()) : le(this.get(), St(this, e ?? r.to));
      Ie(this._pendingCalls, i), r.changed && (r.changed = false, Tt(this, "onRest", i, this));
    }
  }
};
function St(e, t) {
  let r = Ct(t), i = Ct(e.get());
  return ce(i, r);
}
function ts(e, t = e.loop, r = e.to) {
  let i = Ue(t);
  if (i) {
    let o = i !== true && Kn(i), n = (o || e).reverse, s = !o || o.reset;
    return wt({ ...e, loop: t, default: false, pause: void 0, to: !n || hi(r) ? r : void 0, from: s ? e.from : void 0, reset: s, ...o });
  }
}
function wt(e) {
  let { to: t, from: r } = e = Kn(e), i = /* @__PURE__ */ new Set();
  return d.obj(t) && Yn(t, i), d.obj(r) && Yn(r, i), e.keys = i.size ? Array.from(i) : null, e;
}
function Rl(e) {
  let t = wt(e);
  return d.und(t.default) && (t.default = xi(t)), t;
}
function Yn(e, t) {
  $(e, (r, i) => r != null && t.add(i));
}
var wl = ["onStart", "onRest", "onChange", "onPause", "onResume"];
function qn(e, t, r) {
  e.animation[r] = t[r] !== Qn(t, r) ? Zn(t[r], e.key) : void 0;
}
function Tt(e, t, ...r) {
  e.animation[t]?.(...r), e.defaultProps[t]?.(...r);
}
var zl = ["onStart", "onChange", "onRest"];
var Al = 1;
var Ll = class {
  constructor(e, t) {
    this.id = Al++, this.springs = {}, this.queue = [], this._lastAsyncId = 0, this._active = /* @__PURE__ */ new Set(), this._changed = /* @__PURE__ */ new Set(), this._started = false, this._state = { paused: false, pauseQueue: /* @__PURE__ */ new Set(), resumeQueue: /* @__PURE__ */ new Set(), timeouts: /* @__PURE__ */ new Set() }, this._events = { onStart: /* @__PURE__ */ new Map(), onChange: /* @__PURE__ */ new Map(), onRest: /* @__PURE__ */ new Map() }, this._onFrame = this._onFrame.bind(this), t && (this._flush = t), e && this.start({ default: true, ...e });
  }
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((e) => e.idle && !e.isDelayed && !e.isPaused);
  }
  get item() {
    return this._item;
  }
  set item(e) {
    this._item = e;
  }
  get() {
    let e = {};
    return this.each((t, r) => e[r] = t.get()), e;
  }
  set(e) {
    for (let t in e) {
      let r = e[t];
      d.und(r) || this.springs[t].set(r);
    }
  }
  update(e) {
    return e && this.queue.push(wt(e)), this;
  }
  start(e) {
    let { queue: t } = this;
    return e ? t = Z(e).map(wt) : this.queue = [], this._flush ? this._flush(this, t) : (ss(this, t), yi(this, t));
  }
  stop(e, t) {
    if (e !== !!e && (t = e), t) {
      let r = this.springs;
      F(Z(t), (i) => r[i].stop(!!e));
    } else Rt(this._state, this._lastAsyncId), this.each((r) => r.stop(!!e));
    return this;
  }
  pause(e) {
    if (d.und(e)) this.start({ pause: true });
    else {
      let t = this.springs;
      F(Z(e), (r) => t[r].pause());
    }
    return this;
  }
  resume(e) {
    if (d.und(e)) this.start({ pause: false });
    else {
      let t = this.springs;
      F(Z(e), (r) => t[r].resume());
    }
    return this;
  }
  each(e) {
    $(this.springs, e);
  }
  _onFrame() {
    let { onStart: e, onChange: t, onRest: r } = this._events, i = this._active.size > 0, o = this._changed.size > 0;
    (i && !this._started || o && !this._started) && (this._started = true, De(e, ([a, l]) => {
      l.value = this.get(), a(l, this, this._item);
    }));
    let n = !i && this._started, s = o || n && r.size ? this.get() : null;
    o && t.size && De(t, ([a, l]) => {
      l.value = s, a(l, this, this._item);
    }), n && (this._started = false, De(r, ([a, l]) => {
      l.value = s, a(l, this, this._item);
    }));
  }
  eventObserved(e) {
    if (e.type == "change") this._changed.add(e.parent), e.idle || this._active.add(e.parent);
    else if (e.type == "idle") this._active.delete(e.parent);
    else return;
    w.onFrame(this._onFrame);
  }
};
function yi(e, t) {
  return Promise.all(t.map((r) => rs(e, r))).then((r) => Ei(e, r));
}
async function rs(e, t, r) {
  let { keys: i, to: o, from: n, loop: s, onRest: a, onResolve: l } = t, c = d.obj(t.default) && t.default;
  s && (t.loop = false), o === false && (t.to = null), n === false && (t.from = null);
  let g = d.arr(o) || d.fun(o) ? o : void 0;
  g ? (t.to = void 0, t.onRest = void 0, c && (c.onRest = void 0)) : F(zl, (v) => {
    let b = t[v];
    if (d.fun(b)) {
      let p = e._events[v];
      t[v] = ({ finished: h, cancelled: T }) => {
        let O = p.get(b);
        O ? (h || (O.finished = false), T && (O.cancelled = true)) : p.set(b, { value: null, finished: h || false, cancelled: T || false });
      }, c && (c[v] = t[v]);
    }
  });
  let u = e._state;
  t.pause === !u.paused ? (u.paused = t.pause, Ie(t.pause ? u.pauseQueue : u.resumeQueue)) : u.paused && (t.pause = true);
  let y = (i || Object.keys(e.springs)).map((v) => e.springs[v].start(t)), m = t.cancel === true || Qn(t, "cancel") === true;
  (g || m && u.asyncId) && y.push($n(++e._lastAsyncId, { props: t, state: u, actions: { pause: or, resume: or, start(v, b) {
    m ? (Rt(u, e._lastAsyncId), b(tt(e))) : (v.onRest = a, b(Jn(g, v, u, e)));
  } } })), u.paused && await new Promise((v) => {
    u.resumeQueue.add(v);
  });
  let E = Ei(e, await Promise.all(y));
  if (s && E.finished && !(r && E.noop)) {
    let v = ts(t, s, o);
    if (v) return ss(e, [v]), rs(e, v, true);
  }
  return l && w.batchedUpdates(() => l(E, e, e.item)), E;
}
function jn(e, t) {
  let r = { ...e.springs };
  return t && F(Z(t), (i) => {
    d.und(i.keys) && (i = wt(i)), d.obj(i.to) || (i = { ...i, to: void 0 }), ns(r, i, (o) => os(o));
  }), is(e, r), r;
}
function is(e, t) {
  $(t, (r, i) => {
    e.springs[i] || (e.springs[i] = r, ye(r, e));
  });
}
function os(e, t) {
  let r = new Cl();
  return r.key = e, t && ye(r, t), r;
}
function ns(e, t, r) {
  t.keys && F(t.keys, (i) => {
    (e[i] || (e[i] = r(i)))._prepareNode(t);
  });
}
function ss(e, t) {
  F(t, (r) => {
    ns(e.springs, r, (i) => os(i, e));
  });
}
var mr = ({ children: e, ...t }) => {
  let r = Ol(ur), i = t.pause || !!r.pause, o = t.immediate || !!r.immediate;
  t = wn(() => ({ pause: i, immediate: o }), [i, o]);
  let { Provider: n } = ur;
  return dr.createElement(n, { value: t }, e);
};
var ur = Fl(mr, {});
mr.Provider = ur.Provider;
mr.Consumer = ur.Consumer;
function Fl(e, t) {
  return Object.assign(e, dr.createContext(t)), e.Provider._context = e, e.Consumer._context = e, e;
}
var Dl = () => {
  let e = [], t = function(i) {
    Rn();
    let o = [];
    return F(e, (n, s) => {
      if (d.und(i)) o.push(n.start());
      else {
        let a = r(i, n, s);
        a && o.push(n.start(a));
      }
    }), o;
  };
  t.current = e, t.add = function(i) {
    e.includes(i) || e.push(i);
  }, t.delete = function(i) {
    let o = e.indexOf(i);
    ~o && e.splice(o, 1);
  }, t.pause = function() {
    return F(e, (i) => i.pause(...arguments)), this;
  }, t.resume = function() {
    return F(e, (i) => i.resume(...arguments)), this;
  }, t.set = function(i) {
    F(e, (o, n) => {
      let s = d.fun(i) ? i(n, o) : i;
      s && o.set(s);
    });
  }, t.start = function(i) {
    let o = [];
    return F(e, (n, s) => {
      if (d.und(i)) o.push(n.start());
      else {
        let a = this._getProps(i, n, s);
        a && o.push(n.start(a));
      }
    }), o;
  }, t.stop = function() {
    return F(e, (i) => i.stop(...arguments)), this;
  }, t.update = function(i) {
    return F(e, (o, n) => o.update(this._getProps(i, o, n))), this;
  };
  let r = function(i, o, n) {
    return d.fun(i) ? i(n, o) : i;
  };
  return t._getProps = r, t;
};
function Il(e, t, r) {
  let i = d.fun(t) && t;
  i && !r && (r = []);
  let o = fr(() => i || arguments.length == 3 ? Dl() : void 0, []), n = Nn(0), s = _t(), a = fr(() => ({ ctrls: [], queue: [], flush(p, h) {
    let T = jn(p, h);
    return n.current > 0 && !a.queue.length && !Object.keys(T).some((f) => !p.springs[f]) ? yi(p, h) : new Promise((f) => {
      is(p, T), a.queue.push(() => {
        f(yi(p, h));
      }), s();
    });
  } }), []), l = Nn([...a.ctrls]), c = [], g = cr(e) || 0;
  fr(() => {
    F(l.current.slice(e, g), (p) => {
      _l(p, o), p.stop(true);
    }), l.current.length = e, u(g, e);
  }, [e]), fr(() => {
    u(0, Math.min(g, e));
  }, r);
  function u(p, h) {
    for (let T = p; T < h; T++) {
      let O = l.current[T] || (l.current[T] = new Ll(null, a.flush)), f = i ? i(T, O) : t[T];
      f && (c[T] = Rl(f));
    }
  }
  let y = l.current.map((p, h) => jn(p, c[h])), m = xl(mr), E = cr(m), v = m !== E && vl(m);
  ne(() => {
    n.current++, a.ctrls = l.current;
    let { queue: p } = a;
    p.length && (a.queue = [], F(p, (h) => h())), F(l.current, (h, T) => {
      o?.add(h), v && h.start({ default: m });
      let O = c[T];
      O && (yl(h, O.ref), h.ref ? h.queue.push(O) : h.start(O));
    });
  }), $e(() => () => {
    F(a.ctrls, (p) => p.stop(true));
  });
  let b = y.map((p) => ({ ...p }));
  return o ? [b, o] : b;
}
function Si(e, t) {
  let r = d.fun(e), [[i], o] = Il(1, r ? e : [e], r ? t || [] : t);
  return r || arguments.length == 2 ? [i, o] : i;
}
var Ml = class extends bi {
  constructor(e, t) {
    super(), this.source = e, this.idle = true, this._active = /* @__PURE__ */ new Set(), this.calc = Re(...t);
    let r = this._get(), i = Et(r);
    xt(this, i.create(r));
  }
  advance(e) {
    let t = this._get(), r = this.get();
    ce(t, r) || (ie(this).setValue(t), this._onChange(t, this.idle)), !this.idle && Xn(this._active) && mi(this);
  }
  _get() {
    let e = d.arr(this.source) ? this.source.map(K) : Z(K(this.source));
    return this.calc(...e);
  }
  _start() {
    this.idle && !Xn(this._active) && (this.idle = false, F(We(this), (e) => {
      e.done = false;
    }), j.skipAnimation ? (w.batchedUpdates(() => this.advance()), mi(this)) : _e.start(this));
  }
  _attach() {
    let e = 1;
    F(Z(this.source), (t) => {
      re(t) && ye(t, this), gi(t) && (t.idle || this._active.add(t), e = Math.max(e, t.priority + 1));
    }), this.priority = e, this._start();
  }
  _detach() {
    F(Z(this.source), (e) => {
      re(e) && Ne(e, this);
    }), this._active.clear(), mi(this);
  }
  eventObserved(e) {
    e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = Z(this.source).reduce((t, r) => Math.max(t, (gi(r) ? r.priority : 0) + 1), 0));
  }
};
function Nl(e) {
  return e.idle !== false;
}
function Xn(e) {
  return !e.size || Array.from(e).every(Nl);
}
function mi(e) {
  e.idle || (e.idle = true, F(We(e), (t) => {
    t.done = true;
  }), Me(e, { type: "idle", parent: e }));
}
j.assign({ createStringInterpolator: ar, to: (e, t) => new Ml(e, t) });
var Hh = _e.advance;
var Vl = ["primitive"].concat(Object.keys(Bl).filter((e) => /^[A-Z]/.test(e)).map((e) => e[0].toLowerCase() + e.slice(1)));
j.assign({ createStringInterpolator: ar, colors: bn, frameLoop: "demand" });
Hl(() => {
  w.advance();
});
var kl = Mn(Vl, { applyAnimatedValues: Ul });
var cs = kl.animated;
function ls(e, t, r) {
  return class extends hr.LineBasicMaterial {
    constructor() {
      let i = Object.entries(e), o = i.reduce((n, [s, a]) => {
        let l = hr.UniformsUtils.clone({ [s]: { value: a } });
        return M(M({}, n), l);
      }, {});
      super({ color: "#ffffff", linewidth: 5, userData: o, onBeforeCompile: (n) => {
        n.uniforms = M(M({}, n.uniforms), o), n.vertexShader = t;
      } }), i.forEach(([n]) => Object.defineProperty(this, n, { get: () => this.uniforms[n].value, set: (s) => this.uniforms[n].value = s })), r && r(this);
    }
  };
}
function fs(e, t, r, i) {
  return class extends rt.MeshPhysicalMaterial {
    constructor() {
      let o = Object.entries(e), n = e.colors, s = Ti(n[0]), a = Ti(n[1]), l = Ti(n[2]), c = { uC1r: { value: xe(s == null ? void 0 : s.r) }, uC1g: { value: xe(s == null ? void 0 : s.g) }, uC1b: { value: xe(s == null ? void 0 : s.b) }, uC2r: { value: xe(a == null ? void 0 : a.r) }, uC2g: { value: xe(a == null ? void 0 : a.g) }, uC2b: { value: xe(a == null ? void 0 : a.b) }, uC3r: { value: xe(l == null ? void 0 : l.r) }, uC3g: { value: xe(l == null ? void 0 : l.g) }, uC3b: { value: xe(l == null ? void 0 : l.b) } }, g = o.reduce((u, [y, m]) => {
        let E = rt.UniformsUtils.clone({ [y]: { value: m } });
        return M(M({}, u), E);
      }, {});
      super({ metalness: 0.2, userData: g, side: rt.DoubleSide, onBeforeCompile: (u) => {
        u.uniforms = M(M(M({}, u.uniforms), g), c), u.vertexShader = t, u.fragmentShader = r;
      } }), o.forEach(([u]) => Object.defineProperty(this, u, { get: () => this.uniforms[u].value, set: (y) => this.uniforms[u].value = y })), i && i(this);
    }
  };
}
function Ti(e) {
  let t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
  return t ? { r: parseInt(t[1], 16), g: parseInt(t[2], 16), b: parseInt(t[3], 16) } : null;
}
function xe(e = 0) {
  return e / 255;
}
var Ci = {};
pe(Ci, { defaults: () => zt, positionMix: () => Pi });
var zt = {};
pe(zt, { plane: () => pr, sphere: () => gr, waterPlane: () => vr });
var pr = {};
pe(pr, { fragment: () => us, vertex: () => ds });
var us = `#define STANDARD
#ifdef PHYSICAL
#define REFLECTIVITY
#define CLEARCOAT
#define TRANSMISSION
#endif
uniform vec3 diffuse;uniform vec3 emissive;uniform float roughness;uniform float metalness;uniform float opacity;
#ifdef TRANSMISSION
uniform float transmission;
#endif
#ifdef REFLECTIVITY
uniform float reflectivity;
#endif
#ifdef CLEARCOAT
uniform float clearcoat;uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <color_pars_fragment>
#include <common>
#include <dithering_pars_fragment>
#include <emissivemap_pars_fragment>
#include <lightmap_pars_fragment>
#include <map_pars_fragment>
#include <packing>
#include <uv2_pars_fragment>
#include <uv_pars_fragment>
#include <bsdfs>
#include <bumpmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <clipping_planes_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <shadowmap_pars_fragment>
varying vec3 vNormal;varying float displacement;varying vec3 vPos;varying float vDistort;uniform float uC1r;uniform float uC1g;uniform float uC1b;uniform float uC2r;uniform float uC2g;uniform float uC2b;uniform float uC3r;uniform float uC3g;uniform float uC3b;varying vec3 color1;varying vec3 color2;varying vec3 color3;float linearToRelativeLuminance2(const in vec3 color){vec3 weights=vec3(0.2126,0.7152,0.0722);return dot(weights,color.rgb);}void main(){vec3 color1=vec3(uC1r,uC1g,uC1b);vec3 color2=vec3(uC2r,uC2g,uC2b);vec3 color3=vec3(uC3r,uC3g,uC3b);float clearcoat=1.0;float clearcoatRoughness=0.5;
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(mix(mix(color1,color2,smoothstep(-3.0,3.0,vPos.x)),color3,vPos.z),1);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#ifdef TRANSMISSION
float totalTransmission=transmission;
#endif
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <roughnessmap_fragment>
#include <metalnessmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <clearcoat_normal_fragment_begin>
#include <clearcoat_normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_physical_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular;
#ifdef TRANSMISSION
diffuseColor.a*=mix(saturate(1.-totalTransmission+linearToRelativeLuminance2(reflectedLight.directSpecular+reflectedLight.indirectSpecular)),1.0,metalness);
#endif
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
gl_FragColor=vec4(outgoingLight,diffuseColor.a);}`;
var ds = `vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float cnoise(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}mat3 rotation3dY(float angle){float s=sin(angle);float c=cos(angle);return mat3(c,0.0,-s,0.0,1.0,0.0,s,0.0,c);}vec3 rotateY(vec3 v,float angle){return rotation3dY(angle)*v;}varying vec3 vNormal;varying float displacement;varying vec3 vPos;varying float vDistort;varying vec2 vUv;uniform float uTime;uniform float uSpeed;uniform float uLoadingTime;uniform float uNoiseDensity;uniform float uNoiseStrength;
#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif
#include <clipping_planes_pars_vertex>
#include <color_pars_vertex>
#include <common>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <morphtarget_pars_vertex>
#include <shadowmap_pars_vertex>
#include <skinning_pars_vertex>
#include <uv2_pars_vertex>
#include <uv_pars_vertex>
void main(){
#include <beginnormal_vertex>
#include <color_vertex>
#include <defaultnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <uv2_vertex>
#include <uv_vertex>
#ifndef FLAT_SHADED
vNormal=normalize(transformedNormal);
#ifdef USE_TANGENT
vTangent=normalize(transformedTangent);vBitangent=normalize(cross(vNormal,vTangent)*tangent.w);
#endif
#endif
#include <begin_vertex>
#include <clipping_planes_vertex>
#include <displacementmap_vertex>
#include <logdepthbuf_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
#include <skinning_vertex>
vViewPosition=-mvPosition.xyz;
#include <fog_vertex>
#include <shadowmap_vertex>
#include <worldpos_vertex>
vUv=uv;float t=uTime*uSpeed;float distortion=0.75*cnoise(0.43*position*uNoiseDensity+t);vec3 pos=position+normal*distortion*uNoiseStrength*uLoadingTime;vPos=pos;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.);}`;
var gr = {};
pe(gr, { fragment: () => ms, vertex: () => hs });
var ms = `#define STANDARD
#ifdef PHYSICAL
#define REFLECTIVITY
#define CLEARCOAT
#define TRANSMISSION
#endif
uniform vec3 diffuse;uniform vec3 emissive;uniform float roughness;uniform float metalness;uniform float opacity;
#ifdef TRANSMISSION
uniform float transmission;
#endif
#ifdef REFLECTIVITY
uniform float reflectivity;
#endif
#ifdef CLEARCOAT
uniform float clearcoat;uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <color_pars_fragment>
#include <common>
#include <dithering_pars_fragment>
#include <emissivemap_pars_fragment>
#include <lightmap_pars_fragment>
#include <map_pars_fragment>
#include <packing>
#include <uv2_pars_fragment>
#include <uv_pars_fragment>
#include <bsdfs>
#include <bumpmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <clipping_planes_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <shadowmap_pars_fragment>
varying vec3 vNormal;varying float displacement;varying vec3 vPos;varying float vDistort;uniform float uC1r;uniform float uC1g;uniform float uC1b;uniform float uC2r;uniform float uC2g;uniform float uC2b;uniform float uC3r;uniform float uC3g;uniform float uC3b;varying vec3 color1;varying vec3 color2;varying vec3 color3;varying float distanceToCenter;float linearToRelativeLuminance2(const in vec3 color){vec3 weights=vec3(0.2126,0.7152,0.0722);return dot(weights,color.rgb);}void main(){vec3 color1=vec3(uC1r,uC1g,uC1b);vec3 color2=vec3(uC2r,uC2g,uC2b);vec3 color3=vec3(uC3r,uC3g,uC3b);float clearcoat=1.0;float clearcoatRoughness=0.5;
#include <clipping_planes_fragment>
float distanceToCenter=distance(vPos,vec3(0,0,0));vec4 diffuseColor=vec4(mix(color3,mix(color2,color1,smoothstep(-1.0,1.0,vPos.y)),distanceToCenter),1);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#ifdef TRANSMISSION
float totalTransmission=transmission;
#endif
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <roughnessmap_fragment>
#include <metalnessmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <clearcoat_normal_fragment_begin>
#include <clearcoat_normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_physical_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular;
#ifdef TRANSMISSION
diffuseColor.a*=mix(saturate(1.-totalTransmission+linearToRelativeLuminance2(reflectedLight.directSpecular+reflectedLight.indirectSpecular)),1.0,metalness);
#endif
gl_FragColor=vec4(outgoingLight,diffuseColor.a);
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`;
var hs = `vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float pnoise(vec3 P,vec3 rep){vec3 Pi0=mod(floor(P),rep);vec3 Pi1=mod(Pi0+vec3(1.0),rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}varying vec3 vNormal;uniform float uTime;uniform float uSpeed;uniform float uNoiseDensity;uniform float uNoiseStrength;uniform float uFrequency;uniform float uAmplitude;varying vec3 vPos;varying float vDistort;varying vec2 vUv;varying vec3 vViewPosition;
#define STANDARD
#ifndef FLAT_SHADED
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif
#include <clipping_planes_pars_vertex>
#include <color_pars_vertex>
#include <common>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <morphtarget_pars_vertex>
#include <shadowmap_pars_vertex>
#include <skinning_pars_vertex>
#include <uv2_pars_vertex>
#include <uv_pars_vertex>
mat3 rotation3dY(float angle){float s=sin(angle);float c=cos(angle);return mat3(c,0.0,-s,0.0,1.0,0.0,s,0.0,c);}vec3 rotateY(vec3 v,float angle){return rotation3dY(angle)*v;}void main(){
#include <beginnormal_vertex>
#include <color_vertex>
#include <defaultnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <uv2_vertex>
#include <uv_vertex>
#ifndef FLAT_SHADED
vNormal=normalize(transformedNormal);
#ifdef USE_TANGENT
vTangent=normalize(transformedTangent);vBitangent=normalize(cross(vNormal,vTangent)*tangent.w);
#endif
#endif
#include <begin_vertex>
#include <clipping_planes_vertex>
#include <displacementmap_vertex>
#include <logdepthbuf_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
#include <skinning_vertex>
vViewPosition=-mvPosition.xyz;
#include <fog_vertex>
#include <shadowmap_vertex>
#include <worldpos_vertex>
float t=uTime*uSpeed;float distortion=pnoise((normal+t)*uNoiseDensity,vec3(10.0))*uNoiseStrength;vec3 pos=position+(normal*distortion);float angle=sin(uv.y*uFrequency+t)*uAmplitude;pos=rotateY(pos,angle);vPos=pos;vDistort=distortion;vNormal=normal;vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.);}`;
var vr = {};
pe(vr, { fragment: () => ps, vertex: () => gs });
var ps = `#define STANDARD
#ifdef PHYSICAL
#define REFLECTIVITY
#define CLEARCOAT
#define TRANSMISSION
#endif
uniform vec3 diffuse;uniform vec3 emissive;uniform float roughness;uniform float metalness;uniform float opacity;
#ifdef TRANSMISSION
uniform float transmission;
#endif
#ifdef REFLECTIVITY
uniform float reflectivity;
#endif
#ifdef CLEARCOAT
uniform float clearcoat;uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <color_pars_fragment>
#include <common>
#include <dithering_pars_fragment>
#include <emissivemap_pars_fragment>
#include <lightmap_pars_fragment>
#include <map_pars_fragment>
#include <packing>
#include <uv2_pars_fragment>
#include <uv_pars_fragment>
#include <bsdfs>
#include <bumpmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <clipping_planes_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <shadowmap_pars_fragment>
varying vec3 vNormal;varying float displacement;varying vec3 vPos;varying float vDistort;uniform float uC1r;uniform float uC1g;uniform float uC1b;uniform float uC2r;uniform float uC2g;uniform float uC2b;uniform float uC3r;uniform float uC3g;uniform float uC3b;varying vec3 color1;varying vec3 color2;varying vec3 color3;float linearToRelativeLuminance2(const in vec3 color){vec3 weights=vec3(0.2126,0.7152,0.0722);return dot(weights,color.rgb);}void main(){vec3 color1=vec3(uC1r,uC1g,uC1b);vec3 color2=vec3(uC2r,uC2g,uC2b);vec3 color3=vec3(uC3r,uC3g,uC3b);float clearcoat=1.0;float clearcoatRoughness=0.5;
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(mix(mix(color1,color2,smoothstep(-3.0,3.0,vPos.x)),color3,vPos.z),1);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#ifdef TRANSMISSION
float totalTransmission=transmission;
#endif
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <roughnessmap_fragment>
#include <metalnessmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <clearcoat_normal_fragment_begin>
#include <clearcoat_normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_physical_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular;
#ifdef TRANSMISSION
diffuseColor.a*=mix(saturate(1.-totalTransmission+linearToRelativeLuminance2(reflectedLight.directSpecular+reflectedLight.indirectSpecular)),1.0,metalness);
#endif
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
gl_FragColor=vec4(outgoingLight,diffuseColor.a);}`;
var gs = `vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float cnoise(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}mat3 rotation3dY(float angle){float s=sin(angle);float c=cos(angle);return mat3(c,0.0,-s,0.0,1.0,0.0,s,0.0,c);}vec3 rotateY(vec3 v,float angle){return rotation3dY(angle)*v;}varying vec3 vNormal;varying float displacement;varying vec3 vPos;varying float vDistort;uniform float uTime;uniform float uSpeed;uniform float uNoiseDensity;uniform float uNoiseStrength;
#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif
#include <clipping_planes_pars_vertex>
#include <color_pars_vertex>
#include <common>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <morphtarget_pars_vertex>
#include <shadowmap_pars_vertex>
#include <skinning_pars_vertex>
#include <uv2_pars_vertex>
#include <uv_pars_vertex>
void main(){
#include <beginnormal_vertex>
#include <color_vertex>
#include <defaultnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <uv2_vertex>
#include <uv_vertex>
#ifndef FLAT_SHADED
vNormal=normalize(transformedNormal);
#ifdef USE_TANGENT
vTangent=normalize(transformedTangent);vBitangent=normalize(cross(vNormal,vTangent)*tangent.w);
#endif
#endif
#include <begin_vertex>
#include <clipping_planes_vertex>
#include <displacementmap_vertex>
#include <logdepthbuf_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
#include <skinning_vertex>
vViewPosition=-mvPosition.xyz;
#include <fog_vertex>
#include <shadowmap_vertex>
#include <worldpos_vertex>
float t=uTime*uSpeed;float distortion=0.75*cnoise(0.43*position*uNoiseDensity+t);vec3 pos=position+normal*distortion*uNoiseStrength;vPos=pos;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.);}`;
var Pi = {};
pe(Pi, { plane: () => _r, sphere: () => yr, waterPlane: () => xr });
var _r = {};
pe(_r, { fragment: () => vs, vertex: () => _s });
var vs = "uniform float uC1r;uniform float uC1g;uniform float uC1b;uniform float uC2r;uniform float uC2g;uniform float uC2b;uniform float uC3r;uniform float uC3g;uniform float uC3b;varying vec3 vNormal;varying vec3 vPos;void main(){vec3 color1=vec3(uC1r,uC1g,uC1b);vec3 color2=vec3(uC2r,uC2g,uC2b);vec3 color3=vec3(uC3r,uC3g,uC3b);gl_FragColor=vec4(color1*vPos.x+color2*vPos.y+color3*vPos.z,1.);}";
var _s = `vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float cnoise(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}mat3 rotation3dY(float angle){float s=sin(angle);float c=cos(angle);return mat3(c,0.0,-s,0.0,1.0,0.0,s,0.0,c);}vec3 rotateY(vec3 v,float angle){return rotation3dY(angle)*v;}varying vec3 vNormal;varying float displacement;varying vec3 vPos;varying float vDistort;varying vec2 vUv;uniform float uTime;uniform float uSpeed;uniform float uLoadingTime;uniform float uNoiseDensity;uniform float uNoiseStrength;
#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif
#include <clipping_planes_pars_vertex>
#include <color_pars_vertex>
#include <common>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <morphtarget_pars_vertex>
#include <shadowmap_pars_vertex>
#include <skinning_pars_vertex>
#include <uv2_pars_vertex>
#include <uv_pars_vertex>
void main(){
#include <beginnormal_vertex>
#include <color_vertex>
#include <defaultnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <uv2_vertex>
#include <uv_vertex>
#ifndef FLAT_SHADED
vNormal=normalize(transformedNormal);
#ifdef USE_TANGENT
vTangent=normalize(transformedTangent);vBitangent=normalize(cross(vNormal,vTangent)*tangent.w);
#endif
#endif
#include <begin_vertex>
#include <clipping_planes_vertex>
#include <displacementmap_vertex>
#include <logdepthbuf_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
#include <skinning_vertex>
vViewPosition=-mvPosition.xyz;
#include <fog_vertex>
#include <shadowmap_vertex>
#include <worldpos_vertex>
vUv=uv;float t=uTime*uSpeed;float distortion=0.75*cnoise(0.43*position*uNoiseDensity+t);vec3 pos=position+normal*distortion*uNoiseStrength*uLoadingTime;vPos=pos;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.);}`;
var yr = {};
pe(yr, { fragment: () => ys, vertex: () => xs });
var ys = `#define STANDARD
#ifdef PHYSICAL
#define REFLECTIVITY
#define CLEARCOAT
#define TRANSMISSION
#endif
uniform vec3 diffuse;uniform vec3 emissive;uniform float roughness;uniform float metalness;uniform float opacity;
#ifdef TRANSMISSION
uniform float transmission;
#endif
#ifdef REFLECTIVITY
uniform float reflectivity;
#endif
#ifdef CLEARCOAT
uniform float clearcoat;uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <color_pars_fragment>
#include <common>
#include <dithering_pars_fragment>
#include <emissivemap_pars_fragment>
#include <lightmap_pars_fragment>
#include <map_pars_fragment>
#include <packing>
#include <uv2_pars_fragment>
#include <uv_pars_fragment>
#include <bsdfs>
#include <bumpmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <clipping_planes_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <shadowmap_pars_fragment>
varying vec3 vNormal;varying float displacement;varying vec3 vPos;varying float vDistort;uniform float uC1r;uniform float uC1g;uniform float uC1b;uniform float uC2r;uniform float uC2g;uniform float uC2b;uniform float uC3r;uniform float uC3g;uniform float uC3b;varying vec3 color1;varying vec3 color2;varying vec3 color3;varying float distanceToCenter;void main(){vec3 color1=vec3(uC1r,uC1g,uC1b);vec3 color2=vec3(uC2r,uC2g,uC2b);vec3 color3=vec3(uC3r,uC3g,uC3b);float clearcoat=1.0;float clearcoatRoughness=0.5;
#include <clipping_planes_fragment>
float distanceToCenter=distance(vPos,vec3(0,0,0));vec4 diffuseColor=vec4(mix(color3,mix(color2,color1,smoothstep(-1.0,1.0,vPos.y)),distanceToCenter),1);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;
#ifdef TRANSMISSION
float totalTransmission=transmission;
#endif
#include <logdepthbuf_fragment>
#include <map_fragment>
#include <color_fragment>
#include <alphamap_fragment>
#include <alphatest_fragment>
#include <roughnessmap_fragment>
#include <metalnessmap_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <clearcoat_normal_fragment_begin>
#include <clearcoat_normal_fragment_maps>
#include <emissivemap_fragment>
#include <lights_physical_fragment>
#include <lights_fragment_begin>
#include <lights_fragment_maps>
#include <lights_fragment_end>
#include <aomap_fragment>
vec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular;
#ifdef TRANSMISSION
diffuseColor.a*=mix(saturate(1.-totalTransmission+linearToRelativeLuminance(reflectedLight.directSpecular+reflectedLight.indirectSpecular)),1.0,metalness);
#endif
gl_FragColor=vec4(outgoingLight,diffuseColor.a);
#include <tonemapping_fragment>
#include <encodings_fragment>
#include <fog_fragment>
#include <premultiplied_alpha_fragment>
#include <dithering_fragment>
}`;
var xs = `vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float pnoise(vec3 P,vec3 rep){vec3 Pi0=mod(floor(P),rep);vec3 Pi1=mod(Pi0+vec3(1.0),rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}varying vec3 vNormal;uniform float uTime;uniform float uSpeed;uniform float uNoiseDensity;uniform float uNoiseStrength;uniform float uFrequency;uniform float uAmplitude;varying vec3 vPos;varying float vDistort;varying vec2 vUv;varying vec3 vViewPosition;
#define STANDARD
#ifndef FLAT_SHADED
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif
#include <clipping_planes_pars_vertex>
#include <color_pars_vertex>
#include <common>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <morphtarget_pars_vertex>
#include <shadowmap_pars_vertex>
#include <skinning_pars_vertex>
#include <uv2_pars_vertex>
#include <uv_pars_vertex>
mat3 rotation3dY(float angle){float s=sin(angle);float c=cos(angle);return mat3(c,0.0,-s,0.0,1.0,0.0,s,0.0,c);}vec3 rotateY(vec3 v,float angle){return rotation3dY(angle)*v;}void main(){
#include <beginnormal_vertex>
#include <color_vertex>
#include <defaultnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <uv2_vertex>
#include <uv_vertex>
#ifndef FLAT_SHADED
vNormal=normalize(transformedNormal);
#ifdef USE_TANGENT
vTangent=normalize(transformedTangent);vBitangent=normalize(cross(vNormal,vTangent)*tangent.w);
#endif
#endif
#include <begin_vertex>
#include <clipping_planes_vertex>
#include <displacementmap_vertex>
#include <logdepthbuf_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
#include <skinning_vertex>
vViewPosition=-mvPosition.xyz;
#include <fog_vertex>
#include <shadowmap_vertex>
#include <worldpos_vertex>
float t=uTime*uSpeed;float distortion=pnoise((normal+t)*uNoiseDensity,vec3(10.0))*uNoiseStrength;vec3 pos=position+(normal*distortion);float angle=sin(uv.y*uFrequency+t)*uAmplitude;pos=rotateY(pos,angle);vPos=pos;vDistort=distortion;vNormal=normal;vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.);}`;
var xr = {};
pe(xr, { fragment: () => Es, vertex: () => bs });
var Es = "uniform float uC1r;uniform float uC1g;uniform float uC1b;uniform float uC2r;uniform float uC2g;uniform float uC2b;uniform float uC3r;uniform float uC3g;uniform float uC3b;varying vec3 vNormal;varying vec3 vPos;void main(){vec3 color1=vec3(uC1r,uC1g,uC1b);vec3 color2=vec3(uC2r,uC2g,uC2b);vec3 color3=vec3(uC3r,uC3g,uC3b);gl_FragColor=vec4(color1*vPos.x+color2*vPos.y+color3*vPos.z,1.);}";
var bs = `vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}float cnoise(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}mat3 rotation3dY(float angle){float s=sin(angle);float c=cos(angle);return mat3(c,0.0,-s,0.0,1.0,0.0,s,0.0,c);}vec3 rotateY(vec3 v,float angle){return rotation3dY(angle)*v;}varying vec3 vNormal;varying float displacement;varying vec3 vPos;varying float vDistort;varying vec2 vUv;uniform float uTime;uniform float uSpeed;uniform float uLoadingTime;uniform float uNoiseDensity;uniform float uNoiseStrength;
#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
#ifdef USE_TANGENT
varying vec3 vTangent;varying vec3 vBitangent;
#endif
#endif
#include <clipping_planes_pars_vertex>
#include <color_pars_vertex>
#include <common>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <morphtarget_pars_vertex>
#include <shadowmap_pars_vertex>
#include <skinning_pars_vertex>
#include <uv2_pars_vertex>
#include <uv_pars_vertex>
void main(){
#include <beginnormal_vertex>
#include <color_vertex>
#include <defaultnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <uv2_vertex>
#include <uv_vertex>
#ifndef FLAT_SHADED
vNormal=normalize(transformedNormal);
#ifdef USE_TANGENT
vTangent=normalize(transformedTangent);vBitangent=normalize(cross(vNormal,vTangent)*tangent.w);
#endif
#endif
#include <begin_vertex>
#include <clipping_planes_vertex>
#include <displacementmap_vertex>
#include <logdepthbuf_vertex>
#include <morphtarget_vertex>
#include <project_vertex>
#include <skinning_vertex>
vViewPosition=-mvPosition.xyz;
#include <fog_vertex>
#include <shadowmap_vertex>
#include <worldpos_vertex>
vUv=uv;float t=uTime*uSpeed;float distortion=0.75*cnoise(0.43*position*uNoiseDensity+t);vec3 pos=position+normal*distortion*uNoiseStrength*uLoadingTime;vPos=pos;gl_Position=projectionMatrix*modelViewMatrix*vec4(pos,1.);}`;
function Ts({ type: e, shader: t, color1: r, color2: i, color3: o, uTime: n, uSpeed: s, uDensity: a, uStrength: l, uFrequency: c, uAmplitude: g }) {
  let [u, y] = Gl(false), m = e != null ? e : "plane", E = zt[m];
  t && t !== "defaults" && (E = Ci[t][m]);
  let v = fs({ colors: [r, i, o], uTime: n, uSpeed: s, uLoadingTime: 0, uNoiseDensity: a, uNoiseStrength: l, uFrequency: c, uAmplitude: g, uIntensity: 0.5 }, E.vertex, E.fragment), b = ls({ uTime: n, uSpeed: s, uNoiseDensity: a, uNoiseStrength: l, uFrequency: c, uAmplitude: g, uIntensity: 0.5 }, E.vertex);
  return Ss({ ColorShiftMaterial: v }), Ss({ HoveredLineMaterial: b }), Yl(() => {
    y(true);
  }, []), u;
}
var { to: Cs, rotDur: kp, meshDur: Ri, rotDelay: Gp, meshDelay: wi } = Xo;
var zi = new Rs.Clock();
var jl = 20;
function ws({ animate: e, range: t, rangeStart: r, rangeEnd: i }) {
  let o = Ps(), n = Ps(), s = 0;
  return ql((a, l) => {
    if (o.current) {
      let c = zi.getElapsedTime();
      if (t === "enabled" && (c = r, c = c + zi.getElapsedTime(), c >= i && (c = r, zi.start())), c > wi) {
        let g = o.current.userData.uLoadingTime.value, u = c < Ri + wi ? Math.easeInOutCubic(s, g, Cs - g, Ri * 1e3) : Cs;
        o.current.userData.uLoadingTime.value = u, c < Ri + wi && (s += jl);
      }
      e === "on" && (o.current.userData.uTime.value = c, n.current !== void 0 && (n.current.userData.uTime.value = c));
    }
  }), { material: o, linemat: n };
}
Math.easeInOutCubic = function(e, t, r, i) {
  return e /= i / 2, e < 1 ? r / 2 * e * e * e + t : (e -= 2, r / 2 * (e * e * e + 2) + t);
};
var Er = 192;
var br = 36;
var zs = ({ type: e, animate: t, range: r, rangeStart: i, rangeEnd: o, uTime: n, uSpeed: s, uStrength: a, uDensity: l, uFrequency: c, uAmplitude: g, positionX: u, positionY: y, positionZ: m, rotationX: E, rotationY: v, rotationZ: b, color1: p, color2: h, color3: T, reflection: O, wireframe: f, shader: C, rotSpringOption: P = ({ rotation: S }) => ({ to: (R, A) => Pr(void 0, null, function* () {
  yield R({ animatedRotation: S });
}), from: { rotation: Yr([0, 0, 0]) }, config: { duration: 300 } }), posSpringOption: _ = ({ position: S }) => ({ to: (R, A) => Pr(void 0, null, function* () {
  yield R({ animatedPosition: S });
}), from: { position: [0, 0, 0] }, config: { duration: 300 } }) }) => {
  let S = Ts({ type: e, shader: C, color1: p, color2: h, color3: T, uTime: n, uSpeed: s, uDensity: l, uStrength: a, uFrequency: c, uAmplitude: g }), { material: R, linemat: A } = ws({ animate: t, range: r, rangeStart: i, rangeEnd: o }), L = [u, y, m], N = Yr([E, v, b]), { animatedPosition: D } = Si(_({ position: L })), { animatedRotation: k } = Si(P({ rotation: N }));
  return Ai("group", { children: [Ai(cs.mesh, { position: D, rotation: k, name: "shadergradient-mesh", children: [e === "plane" && Ee("planeGeometry", { args: [10, 10, 1, Er] }), e === "sphere" && Ee("icosahedronGeometry", { args: [1, Er / 3] }), e === "waterPlane" && Ee("planeGeometry", { args: [10, 10, Er, Er] }), S && Ee("colorShiftMaterial", { ref: R, roughness: 1 - O })] }), Ee("mesh", { children: Ai("lineSegments", { renderOrder: 1, position: L, rotation: N, visible: false, children: [e === "plane" && Ee("planeGeometry", { args: [10, 10, 1, br] }), e === "sphere" && Ee("icosahedronGeometry", { args: [1, br / 3] }), e === "waterPlane" && Ee("planeGeometry", { args: [10, 10, br, br] }), S && Ee("hoveredLineMaterial", { ref: A })] }) })] });
};
var Di = ia(Zs());
var Fi = [{ title: "Halo", color: "white", url: "?range=enabled&rangeStart=0&rangeEnd=40&frameRate=10&destination=onCanvas&format=gif&animate=on&axesHelper=off&brightness=1.2&cAzimuthAngle=180&cDistance=3.6&cPolarAngle=90&cameraZoom=1&color1=%23ff5005&color2=%23dbba95&color3=%23d0bce1&embedMode=off&envPreset=city&gizmoHelper=hide&grain=on&lightType=3d&pixelDensity=1&fov=45&positionX=-1.4&positionY=0&positionZ=0&reflection=0.1&rotationX=0&rotationY=10&rotationZ=50&shader=defaults&type=plane&uDensity=1.3&uSpeed=0.4&uStrength=4&uTime=0&uFrequency=5.5&wireframe=false" }, { title: "Pensive", color: "white", url: "?range=enabled&rangeStart=0&rangeEnd=40&frameRate=10&destination=onCanvas&format=gif&animate=on&axesHelper=off&brightness=1.5&cAzimuthAngle=250&cDistance=1.5&cPolarAngle=140&cameraZoom=12.5&color1=%23809bd6&color2=%23910aff&color3=%23af38ff&embedMode=off&envPreset=city&gizmoHelper=hide&grain=on&lightType=3d&pixelDensity=1&fov=45&positionX=0&positionY=0&positionZ=0&reflection=0.5&rotationX=0&rotationY=0&rotationZ=140&shader=defaults&type=sphere&uAmplitude=7&uDensity=0.8&uFrequency=5.5&uSpeed=0.3&uStrength=0.4&uTime=0&wireframe=false" }, { title: "Mint", color: "white", url: "?range=enabled&rangeStart=0&rangeEnd=40&frameRate=10&destination=onCanvas&format=gif&animate=on&axesHelper=off&brightness=1.2&cAzimuthAngle=170&cDistance=4.4&cPolarAngle=70&cameraZoom=1&color1=%2394ffd1&color2=%236bf5ff&color3=%23ffffff&embedMode=off&envPreset=city&gizmoHelper=hide&grain=off&lightType=3d&pixelDensity=1&fov=45&positionX=0&positionY=0.9&positionZ=-0.3&reflection=0.1&rotationX=45&rotationY=0&rotationZ=0&type=waterPlane&uAmplitude=0&uDensity=1.2&uFrequency=0&uSpeed=0.2&uStrength=3.4&uTime=0&wireframe=false&shader=defaults" }, { title: "Interstella", color: "white", url: "?range=enabled&rangeStart=0&rangeEnd=40&frameRate=10&destination=onCanvas&format=gif&animate=on&axesHelper=off&brightness=0.8&cAzimuthAngle=270&cDistance=0.5&cPolarAngle=180&cameraZoom=15.1&color1=%2373bfc4&color2=%23ff810a&color3=%238da0ce&embedMode=off&envPreset=city&gizmoHelper=hide&grain=on&lightType=env&pixelDensity=1&fov=45&positionX=-0.1&positionY=0&positionZ=0&reflection=0.4&rotationX=0&rotationY=130&rotationZ=70&shader=defaults&type=sphere&uAmplitude=3.2&uDensity=0.8&uFrequency=5.5&uSpeed=0.3&uStrength=0.3&uTime=0&wireframe=false" }, { title: "Nighty night", color: "white", url: "?range=enabled&rangeStart=0&rangeEnd=40&frameRate=10&destination=onCanvas&format=gif&animate=on&axesHelper=off&brightness=1&cAzimuthAngle=180&cDistance=2.8&cPolarAngle=80&cameraZoom=9.1&color1=%23606080&color2=%238d7dca&color3=%23212121&embedMode=off&envPreset=city&gizmoHelper=hide&grain=on&lightType=3d&pixelDensity=1&fov=45&positionX=0&positionY=0&positionZ=0&reflection=0.1&rotationX=50&rotationY=0&rotationZ=-60&shader=defaults&type=waterPlane&uAmplitude=0&uDensity=1.5&uFrequency=0&uSpeed=0.3&uStrength=1.5&uTime=8&wireframe=false" }, { title: "Viola orientalis", color: "white", url: "?range=enabled&rangeStart=0&rangeEnd=40&frameRate=10&destination=onCanvas&format=gif&animate=on&axesHelper=on&brightness=1.1&cAzimuthAngle=0&cDistance=7.1&cPolarAngle=140&cameraZoom=17.3&color1=%23ffffff&color2=%23ffbb00&color3=%230700ff&embedMode=off&envPreset=city&grain=off&lightType=3d&pixelDensity=1&fov=45&positionX=0&positionY=0&positionZ=0&reflection=0.1&rotationX=0&rotationY=0&rotationZ=0&type=sphere&uAmplitude=1.4&uDensity=1.1&uSpeed=0.1&uStrength=1&uTime=0&wireframe=false&uFrequency=5.5&shader=defaults" }, { title: "Universe", color: "white", url: "?range=enabled&rangeStart=0&rangeEnd=40&frameRate=10&destination=onCanvas&format=gif&animate=on&axesHelper=on&brightness=1.1&cAzimuthAngle=180&cDistance=3.9&cPolarAngle=115&cameraZoom=1&color1=%235606FF&color2=%23FE8989&color3=%23000000&embedMode=off&envPreset=city&grain=off&lightType=3d&pixelDensity=1&fov=45&positionX=-0.5&positionY=0.1&positionZ=0&reflection=0.1&rotationX=0&rotationY=0&rotationZ=235&type=waterPlane&uAmplitude=0&uDensity=1.1&uSpeed=0.1&uStrength=2.4&uTime=0.2&uFrequency=5.5&wireframe=false&shader=defaults" }, { title: "Sunset", color: "white", url: "?range=enabled&rangeStart=0&rangeEnd=40&frameRate=10&destination=onCanvas&format=gif&animate=on&axesHelper=on&bgColor1=%23000000&bgColor2=%23000000&brightness=1.5&cAzimuthAngle=60&cDistance=7.1&cPolarAngle=90&cameraZoom=15.3&color1=%23ff7a33&color2=%2333a0ff&color3=%23ffc53d&embedMode=off&envPreset=dawn&grain=off&http%3A%2F%2Flocalhost%3A3002%2Fcustomize%3Fanimate=on&lightType=3d&pixelDensity=1&fov=45&positionX=0&positionY=-0.15&positionZ=0&reflection=0.1&rotationX=0&rotationY=0&rotationZ=0&shader=defaults&type=sphere&uAmplitude=1.4&uDensity=1.1&uSpeed=0.1&uStrength=0.4&uTime=0&uFrequency=5.5&wireframe=false" }, { title: "Mandarin", color: "white", url: "?range=enabled&rangeStart=0&rangeEnd=40&frameRate=10&destination=onCanvas&format=gif&animate=on&axesHelper=on&bgColor1=%23000000&bgColor2=%23000000&brightness=1.2&cAzimuthAngle=180&cDistance=2.4&cPolarAngle=95&cameraZoom=1&color1=%23ff6a1a&color2=%23c73c00&color3=%23FD4912&embedMode=off&envPreset=city&grain=off&lightType=3d&pixelDensity=1&fov=45&positionX=0&positionY=-2.1&positionZ=0&reflection=0.1&rotationX=0&rotationY=0&rotationZ=225&shader=defaults&type=waterPlane&uAmplitude=0&uFrequency=5.5&uDensity=1.8&uSpeed=0.2&uStrength=3&uTime=0.2&wireframe=false" }, { title: "Cotton Candy", color: "white", url: "?range=enabled&rangeStart=0&rangeEnd=40&frameRate=10&destination=onCanvas&format=gif&animate=on&axesHelper=off&brightness=1.2&cAzimuthAngle=180&cDistance=2.9&cPolarAngle=120&cameraZoom=1&color1=%23ebedff&color2=%23f3f2f8&color3=%23dbf8ff&embedMode=off&envPreset=city&gizmoHelper=hide&grain=off&lightType=3d&pixelDensity=1&fov=45&positionX=0&positionY=1.8&positionZ=0&reflection=0.1&rotationX=0&rotationY=0&rotationZ=-90&type=waterPlane&uDensity=1&uSpeed=0.3&uStrength=3&uTime=0.2&uFrequency=5.5&wireframe=false&shader=defaults" }];
var fg = Fi[0].url;
var rf = Di.parse(qr(Fi[0].url), { parseNumbers: true, parseBooleans: true, arrayFormat: "index" });
function gg(a) {
  var l = a, { control: e = "props", dampingFactor: t, rotSpringOption: r, posSpringOption: i, isFigmaPlugin: o = false, enableTransition: n = true } = l, s = J(l, ["control", "dampingFactor", "rotSpringOption", "posSpringOption", "isFigmaPlugin", "enableTransition"]);
  let c = M(M({}, rf), s);
  e === "query" && (c = Di.parse(qr(s.urlString), { parseNumbers: true, parseBooleans: true, arrayFormat: "index" }));
  let b = c, { lightType: g, envPreset: u, brightness: y, grain: m, toggleAxis: E } = b, v = J(b, ["lightType", "envPreset", "brightness", "grain", "toggleAxis"]);
  return Ar(m === "off"), nf(of, { children: [Sr(rn, { lightType: g, brightness: y, envPreset: u }), Sr(zs, W(M({}, v), { rotSpringOption: r, posSpringOption: i }), JSON.stringify(v)), E && Sr(Fo, { isFigmaPlugin: o }), Sr($o, W(M({ dampingFactor: t }, v), { enableTransition: n }))] });
}

// /:https://framerusercontent.com/modules/OyQTynK6SZJkLA6wYpTv/XdGxLGHd8DKcr2HGyULS/ShaderGradient.js
import { addPropertyControls, Color, ControlType, RenderTarget } from "unframer";
var isCanvas = RenderTarget.current() !== RenderTarget.preview;
var ShaderGradient = ({ color1, color2, color3, noise, cameraAngle, position, rotation, pointerEvents, performantOnCanvas, ...props }) => {
  if (isCanvas && performantOnCanvas) return /* @__PURE__ */ _jsx(ki, { color1, color2 });
  return /* @__PURE__ */ _jsx(gf, { resize: { offsetSize: true }, pointerEvents, children: /* @__PURE__ */ _jsx(gg, { color1: Color.toHex(Color(parseToken(color1))), color2: Color.toHex(Color(parseToken(color2))), color3: Color.toHex(Color(parseToken(color3))), isFigmaPlugin: true, ...noise, ...position, ...cameraAngle, ...rotation, ...props }) }, props.control + props.urlString);
};
function AddControls(Comp) {
  Comp.defaultProps = { control: "props", animate: "on", brightness: 1.2, cDistance: 3.6, cameraZoom: 1, color1: "#ff5005", color2: "#dbba95", color3: "#d0bce1", embedMode: "off", envPreset: "city", gizmoHelper: "hide", grain: "on", lightType: "3d", pixelDensity: 1, reflection: 0.1, shader: "defaults", type: "plane", uSpeed: 0.4, uTime: 0, wireframe: "false", zoomOut: false, toggleAxis: false, pointerEvents: "none" };
  addPropertyControls(Comp, {
    control: { type: ControlType.Enum, options: ["props", "query"], optionTitles: ["Props", "Query"], displaySegmentedControl: true },
    activeTab: { title: "Settings Group", type: ControlType.Enum, options: ["Shape", "Colors", "Effects", "View"], hidden: (props) => props.control === "query" },
    // Shape
    type: { type: ControlType.Enum, options: ["plane", "sphere", "waterPlane"], optionTitles: ["Plane", "Sphere", "Water"], displaySegmentedControl: true, hidden: (props) => props.control === "query" || props.activeTab !== "Shape" },
    shader: { type: ControlType.Enum, options: ["defaults", "positionMix"], optionTitles: ["Type A", "Type B"], displaySegmentedControl: true, hidden: (props) => props.control === "query" || props.activeTab !== "Shape" },
    animate: { type: ControlType.Enum, options: ["on", "off"], optionTitles: ["On", "Off"], displaySegmentedControl: true, hidden: (props) => props.control === "query" || props.activeTab !== "Shape" && props.activeTab !== "URL" },
    uTime: { title: "Movements", type: ControlType.Number, step: 0.1, displayStepper: true, hidden: (props) => props.animate === "on" || props.control === "query" || props.activeTab !== "Shape" },
    uSpeed: { title: "Speed", type: ControlType.Number, step: 0.1, min: 0.1, displayStepper: true, hidden: (props) => props.animate === "off" || props.control === "query" || props.activeTab !== "Shape" },
    noise: { type: ControlType.Object, controls: { uStrength: { type: ControlType.Number, title: "Strength", step: 0.1, min: 0.1, displayStepper: true, defaultValue: 4 }, uDensity: { type: ControlType.Number, title: "Density", step: 0.1, min: 0.1, displayStepper: true, defaultValue: 1.3 } }, hidden: (props) => props.control === "query" || props.activeTab !== "Shape" },
    uAmplitude: { type: ControlType.Number, title: "Spiral", step: 0.1, min: 0.1, displayStepper: true, hidden: (props) => props.type !== "sphere" || props.control === "query" || props.activeTab !== "Shape" },
    pixelDensity: { type: ControlType.Number, step: 0.1, min: 0, max: 3, displayStepper: true, hidden: (props) => props.control === "query" || props.activeTab !== "Shape" },
    // Effects
    grain: { type: ControlType.Enum, options: ["on", "off"], optionTitles: ["On", "Off"], displaySegmentedControl: true, hidden: (props) => props.control === "query" || props.activeTab !== "Effects" },
    lightType: { type: ControlType.Enum, options: ["env", "3d"], optionTitles: ["Env", "Light"], displaySegmentedControl: true, hidden: (props) => props.control === "query" || props.activeTab !== "Effects" },
    envPreset: { type: ControlType.Enum, options: ["city", "dawn", "lobby"], optionTitles: ["City", "Dawn", "Lobby"], displaySegmentedControl: true, hidden: (props) => props.lightType === "3d" || props.control === "query" || props.activeTab !== "Effects" },
    brightness: { type: ControlType.Number, step: 0.1, min: 0.1, max: 3, hidden: (props) => props.lightType === "env" || props.control === "query" || props.activeTab !== "Effects" || props.url },
    reflection: { type: ControlType.Number, step: 0.1, min: 0, max: 1, hidden: (props) => props.lightType === "3d" || props.control === "query" || props.activeTab !== "Effects" || props.url },
    // Colors
    color1: { type: ControlType.Color, hidden: (props) => props.control === "query" || props.activeTab !== "Colors" },
    color2: { type: ControlType.Color, hidden: (props) => props.control === "query" || props.activeTab !== "Colors" },
    color3: { type: ControlType.Color, hidden: (props) => props.control === "query" || props.activeTab !== "Colors" },
    // View
    cDistance: { title: "Distance", type: ControlType.Number, displayStepper: true, min: 0, max: 20, hidden: (props) => props.type === "sphere" || props.control === "query" || props.activeTab !== "View" },
    cameraZoom: { type: ControlType.Number, displayStepper: true, step: 0.1, min: 0.1, max: 30, hidden: (props) => props.type !== "sphere" || props.control === "query" || props.activeTab !== "View" },
    cameraAngle: { type: ControlType.Object, controls: { cAzimuthAngle: { title: "Azimuth", type: ControlType.Number, displayStepper: true, step: 10, min: 0, max: 360, defaultValue: 0 }, cPolarAngle: { title: "Polar", type: ControlType.Number, displayStepper: true, step: 10, min: 0, max: 180, defaultValue: 90 } }, hidden: (props) => props.control === "query" || props.activeTab !== "View" },
    position: { type: ControlType.Object, controls: { positionX: { type: ControlType.Number, step: 0.1, displayStepper: true, defaultValue: -1.4 }, positionY: { type: ControlType.Number, step: 0.1, displayStepper: true }, positionZ: { type: ControlType.Number, step: 0.1, displayStepper: true } }, hidden: (props) => props.control === "query" || props.activeTab !== "View" },
    rotation: { type: ControlType.Object, controls: { rotationX: { type: ControlType.Number, step: 10, min: -360, max: 360, displayStepper: true, defaultValue: 0 }, rotationY: { type: ControlType.Number, step: 10, min: -360, max: 360, displayStepper: true, defaultValue: 0 }, rotationZ: { type: ControlType.Number, step: 10, min: -360, max: 360, displayStepper: true, defaultValue: 0 } }, hidden: (props) => props.control === "query" || props.activeTab !== "View" },
    // urlString
    urlString: { type: ControlType.String, placeholder: "URL from shadergradient.co", hidden: (props) => props.control === "props" },
    // Tools ()
    zoomOut: { type: ControlType.Boolean, title: "View", enabledTitle: "Wide", disabledTitle: "-", hidden: (props) => props.control === "query" },
    toggleAxis: { type: ControlType.Boolean, title: "Axis", enabledTitle: "Guide", disabledTitle: "-", hidden: (props) => props.control === "query" },
    pointerEvents: { type: ControlType.Enum, title: "Touch Control", options: ["none", "auto"], optionTitles: ["Disable", "Enable"], displaySegmentedControl: true, hidden: (props) => props.control === "query" },
    performantOnCanvas: { type: ControlType.Boolean, defaultValue: false }
  });
}
AddControls(ShaderGradient);
function parseToken(colorString) {
  if (colorString.startsWith("var(")) {
    const regex = /(rgba?)\((\d+),\s*(\d+),\s*(\d+)(,\s*([\d.]+))?\)/;
    const matches = colorString.match(regex);
    if (matches) {
      const isRgba = matches[1] === "rgba";
      const red = parseInt(matches[2]);
      const green = parseInt(matches[3]);
      const blue = parseInt(matches[4]);
      const alpha = isRgba ? parseFloat(matches[6]) : 1;
      return `rgba(${red}, ${green}, ${blue}, ${alpha})`;
    }
  } else return colorString;
}
var stdin_default = ShaderGradient;

export {
  stdin_default
};
/*! Bundled license information:

camera-controls/dist/camera-controls.module.js:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
*/
