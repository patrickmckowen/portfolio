/**
 * # MCP to CLI
 *
 * Dynamically generates CLI commands from MCP (Model Context Protocol) server tools.
 * This module connects to any MCP server, discovers available tools, and creates
 * corresponding CLI commands with proper argument parsing and validation.
 *
 * ## Features
 *
 * - **Auto-discovery**: Fetches all tools from the MCP server and creates CLI commands
 * - **Caching**: Tools are cached for 1 hour to avoid reconnecting on every invocation
 * - **Session reuse**: MCP session IDs are cached to skip initialization handshake
 * - **Type-aware parsing**: Handles string, number, boolean, object, and array arguments
 * - **JSON schema support**: Generates CLI options from tool input schemas
 * - **OAuth support**: Automatic OAuth authentication on 401 errors (lazy auth)
 *
 * ## Example Usage
 *
 * ```ts
 * import { cac } from '@xmorse/cac'
 * import { addMcpCommands } from 'mcpcac'
 *
 * const cli = cac('mycli')
 *
 * await addMcpCommands({
 *   cli,
 *   commandPrefix: 'mcp',
 *   clientName: 'my-mcp-client',
 *   getMcpUrl: () => loadConfig().mcpUrl,
 *   oauth: {
 *     clientName: 'My CLI',
 *     load: () => loadConfig().mcpOauth,
 *     save: (state) => saveConfig({ mcpOauth: state }),
 *   },
 *   loadCache: () => loadConfig().cachedMcpTools,
 *   saveCache: (cache) => saveConfig({ cachedMcpTools: cache }),
 * })
 *
 * // Login command just saves URL - no auth check, fast!
 * cli.command('login [url]').action((url) => {
 *   saveConfig({ mcpUrl: url })
 *   console.log('URL saved.')
 * })
 *
 * cli.parse()
 * ```
 *
 * @module mcpcac
 */
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { FileOAuthProvider } from "./oauth-provider.js";
import { startOAuthFlow, isAuthRequiredError } from "./auth.js";
const CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour
/**
 * Convert JSON schema to compact JSON string for display
 */
function schemaToString(schema) {
    const compact = { ...schema };
    delete compact.description;
    return JSON.stringify(compact);
}
function parseToolArguments(options, inputSchema) {
    const args = {};
    if (!inputSchema?.properties) {
        return args;
    }
    for (const [name, schema] of Object.entries(inputSchema.properties)) {
        let value = options[name];
        if (value === undefined) {
            continue;
        }
        if (Array.isArray(value) && value.length === 1) {
            value = value[0];
        }
        const type = schema.type || "string";
        if ((type === "object" || type === "array") && typeof value === "string") {
            try {
                args[name] = JSON.parse(value);
            }
            catch {
                console.error(`Invalid JSON for --${name}: ${value}`);
                process.exit(1);
            }
        }
        else {
            args[name] = value;
        }
    }
    return args;
}
function outputResult(result) {
    for (const block of result.content) {
        if (block.type === "text" && block.text) {
            console.log(block.text);
        }
        else if (block.type === "image") {
            console.log("[Image content omitted]");
        }
        else {
            console.log(JSON.stringify(block, null, 2));
        }
    }
}
/**
 * Create a transport with optional OAuth authentication
 */
function createTransportWithAuth(url, sessionId, oauthState, oauth) {
    let authProvider;
    if (oauth && oauthState?.tokens) {
        authProvider = new FileOAuthProvider({
            serverUrl: url.toString(),
            redirectUri: "http://localhost/callback", // Placeholder, real one set during auth flow
            clientName: oauth.clientName,
            tokens: oauthState.tokens,
            clientInformation: oauthState.clientInformation,
            codeVerifier: oauthState.codeVerifier,
            onStateUpdated: (newState) => {
                oauth.save(newState);
            },
        });
    }
    return new StreamableHTTPClientTransport(url, {
        sessionId,
        authProvider,
    });
}
/**
 * Normalize MCP URL for StreamableHTTP transport
 */
function normalizeUrl(mcpUrl) {
    const url = new URL(mcpUrl);
    if (url.pathname.endsWith("/sse")) {
        url.pathname = url.pathname.replace(/\/sse$/, "/mcp");
    }
    return url;
}
/**
 * Adds MCP tool commands to a cac CLI instance.
 *
 * Tools are cached for 1 hour to avoid connecting on every CLI invocation.
 * Session ID is also cached to skip MCP initialization handshake.
 *
 * OAuth is lazy - authentication only happens when a 401 error occurs.
 * After successful auth, the operation is automatically retried.
 */
export async function addMcpCommands(options) {
    const { cli, commandPrefix = "mcp", clientName = "mcp-cli-client", getMcpUrl, getMcpTransport, oauth, loadCache, saveCache, } = options;
    // Helper to get transport - supports both old and new API
    const getTransport = async (sessionId) => {
        // New API: getMcpUrl + oauth
        if (getMcpUrl) {
            const mcpUrl = getMcpUrl();
            if (!mcpUrl) {
                return null;
            }
            const url = normalizeUrl(mcpUrl);
            const oauthState = oauth?.load();
            return createTransportWithAuth(url, sessionId, oauthState, oauth);
        }
        // Legacy API: getMcpTransport
        if (getMcpTransport) {
            return getMcpTransport(sessionId);
        }
        return null;
    };
    // Handle auth required - triggers OAuth flow internally
    const handleAuthRequired = async (serverUrl) => {
        if (!oauth) {
            console.error("Authentication required but OAuth not configured.");
            console.error("Add oauth config to addMcpCommands() to enable automatic authentication.");
            return false;
        }
        console.log("\nüîê Authentication required. Opening browser...\n");
        const result = await startOAuthFlow({
            serverUrl,
            clientName: oauth.clientName,
            existingState: oauth.load(),
            onAuthUrl: oauth.onAuthUrl,
        });
        if (result.success && result.state) {
            oauth.save(result.state);
            oauth.onAuthSuccess?.();
            console.log("‚úì Authentication successful! Retrying...\n");
            return true;
        }
        oauth.onAuthError?.(result.error || "Unknown error");
        console.error(`‚úó Authentication failed: ${result.error}\n`);
        return false;
    };
    // Try to use cached tools first (fast path - no network)
    const cachedTools = loadCache();
    const isCacheValid = cachedTools && (Date.now() - cachedTools.timestamp) < CACHE_TTL_MS;
    let tools;
    let cachedSessionId;
    if (isCacheValid) {
        tools = cachedTools.tools;
        cachedSessionId = cachedTools.sessionId;
    }
    else {
        // Cache invalid/missing - connect to fetch tools
        const transport = await getTransport();
        if (!transport) {
            return;
        }
        const client = new Client({ name: clientName, version: "1.0.0" }, { capabilities: {} });
        try {
            await client.connect(transport);
            const result = await client.listTools();
            tools = result.tools;
            const sessionId = transport.sessionId;
            saveCache({
                tools: tools.map((t) => ({
                    name: t.name,
                    description: t.description,
                    inputSchema: t.inputSchema,
                })),
                timestamp: Date.now(),
                sessionId,
            });
            cachedSessionId = sessionId;
        }
        catch (err) {
            // Check if auth is required during tool discovery
            if (isAuthRequiredError(err) && oauth && getMcpUrl) {
                const mcpUrl = getMcpUrl();
                if (mcpUrl) {
                    const authSuccess = await handleAuthRequired(normalizeUrl(mcpUrl).toString());
                    if (authSuccess) {
                        // Retry after auth
                        return addMcpCommands(options);
                    }
                }
            }
            console.error(`Failed to connect to MCP server: ${err instanceof Error ? err.message : err}`);
            return;
        }
        finally {
            await client.close();
        }
    }
    // Register CLI commands for each tool
    for (const tool of tools) {
        const inputSchema = tool.inputSchema;
        const cmdName = commandPrefix ? `${commandPrefix} ${tool.name}` : tool.name;
        const description = tool.description || `Run MCP tool ${tool.name}`;
        const cmd = cli.command(cmdName, description);
        if (inputSchema?.properties) {
            for (const [propName, propSchema] of Object.entries(inputSchema.properties)) {
                const isRequired = inputSchema.required?.includes(propName) ?? false;
                const schemaType = propSchema.type || "string";
                const optionStr = schemaType === "boolean" ? `--${propName}` : `--${propName} <${propName}>`;
                let optionDesc = propSchema.description || propName;
                if (isRequired) {
                    optionDesc += " (required)";
                }
                if (schemaType === "object" || schemaType === "array") {
                    optionDesc += ` (JSON: ${schemaToString(propSchema)})`;
                }
                const optionConfig = {};
                if (propSchema.default !== undefined) {
                    optionConfig.default = propSchema.default;
                }
                if (schemaType === "number" || schemaType === "integer") {
                    optionConfig.type = [Number];
                }
                else if (schemaType !== "boolean") {
                    optionConfig.type = [String];
                }
                cmd.option(optionStr, optionDesc, optionConfig);
            }
        }
        cmd.action(async (cliOptions) => {
            const parsedArgs = parseToolArguments(cliOptions, inputSchema);
            const executeWithRetry = async (isRetry = false) => {
                const transport = await getTransport(isRetry ? undefined : cachedSessionId);
                if (!transport) {
                    console.error("MCP transport not available. Run login command first.");
                    process.exit(1);
                }
                const actionClient = new Client({ name: clientName, version: "1.0.0" }, { capabilities: {} });
                try {
                    await actionClient.connect(transport);
                    const result = await actionClient.callTool({ name: tool.name, arguments: parsedArgs });
                    outputResult(result);
                }
                catch (err) {
                    // On 401, trigger OAuth and retry (only once)
                    if (!isRetry && isAuthRequiredError(err) && oauth && getMcpUrl) {
                        const mcpUrl = getMcpUrl();
                        if (mcpUrl) {
                            const authSuccess = await handleAuthRequired(normalizeUrl(mcpUrl).toString());
                            if (authSuccess) {
                                await actionClient.close();
                                return executeWithRetry(true);
                            }
                        }
                    }
                    // Clear cache on error (might be stale)
                    saveCache(undefined);
                    console.error(`Error calling ${tool.name}:`, err instanceof Error ? err.message : err);
                    process.exit(1);
                }
                finally {
                    await actionClient.close();
                }
            };
            await executeWithRetry();
        });
    }
}
